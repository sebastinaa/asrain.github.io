title: 数据结构重点
date: 2015-08-04 23:40:48
tags: 大学课程
-----

第零章 绪论
-----------------

什么是计算机算法？算法的**五大特征**？算法设计的要求？

* 计算机算法指`解决问题的步骤序列`。

* 算法的五大特征分别为

		可行性、有穷性、确定性、输入、输出

* 算法设计要求

		正确性、可读性、健壮性、效率与低存储量需求
<!--more-->
你得学会分析一个算法的时间复杂度，至于空间复杂度，后者好分析，你只要保证你会前者就行了。

如何分析一个算法的时间复杂度？


从我们现在接触的算法来看，*log N*的产生是因为**二分**，N的产生是因为for/while循环，大概地，一层循环乘一个N，二分的循环乘 *log N*。（但这只是一种`感觉`，请不要当真，因为KMP算法中`匹配函数`的时间复杂度是O(N)[^3]，虽然有2层循环...）

比如快速排序，就有二分的思想，又循环一次，你懂的， **O(NlogN)**，冒泡，选择排序，插入排序，二次循环，**O(N<sup>2</sup>)**。

如果一个算法要算3\*n^2+n+1次，它时间复杂度并非O(3\*n^2+n+1),而是O(n^2)，时间复杂度只取决于指数最高的那一项，且忽略常数项。
然后有一些**概念你要知道**,在**书1.2节**。

* 从逻辑上把数据结构分成**_线性结构和非线性结构_**
* 物理结构是**数据结构在计算机中的表示**
* **数据**是对客观事物的符号表示。
* **数据元素**是数据的基本单位。
* **数据对象**是性质相同的数据元素。
* **数据结构**是相互之间存在一种或多种特定关系的数据元素的集合。
* 数据元素之间的关系在计算机中的**两种不同的表示方法**：**顺序映像**和**非顺序映像**。
* 两种不同的存储结构：顺序存储结构和链式存储结构。
* 数据的逻辑结构指***数据元素之间的逻辑关系***
* **抽象数据类型**是指一个数学模型以及定义在该模型上的一组操作。
* 以上概念考***填空题***的概率较大。



第一章 线性表
-------------
必考：该章没什么好说的，简单，但有可能写代码，请注意要会所有**概念，也就是原理**。
还有**线性表（顺序存储结构）和链表（链式存储结构）的优劣性，比如链表插入时间复杂度是O(1)，而线性表是O(N)；线性表有存储上限，但链表没有**。刚刚说的优劣性，是可以拿性命担保必考的。

代码的话，很可能是写往线性表（或链表）插入一个元素之类的，只求过的话代码你就可以不用会写了。

线性表插入一个元素的e.g:
		
		#include <stdio.h>
		typedef struct{
			int a[MAXLEN];//数组实现
			int end;
		}list; // typedef一个list类型
		
		void MoveTheElemsToright(list *l,int n){
			for (int i = l->end; i>=n; i--)
				l->a[i+1]=l->a[i];
		}//腾出第n+1个空间（将第n+1数开始往右移一格）
		
		bool InstertAnElemNormal(list *l,int n,int number){
			if(n>l->end+1||n<0||l->end==MAXLEN-1) return false;//加强鲁棒性，然而并没有什么软用！
			else MoveTheElemsToright(l,n);
			l->a[n] = number;
			l->end++;
			return true;
		}// insert an elem at the (n+1)th place
		

第二章 栈和队列
----------------
这都是基础的数据结构，同样有可能写(伪)代码实现，同样要会所有**概念**。

连概念都不懂的可以去看 

* 严奶奶的书
* [我叫**队列还有bfs(他们是分开的所以你可以不看后者23333)**概念的传送门](http://blueve.me/archives/417)
* [我真找不到谁的博客详细写了栈的概念，栈原理不懂的话，这个是百度的传送门](http://www.baidu.com)

堆栈实际上就是 **先入后出**(first in last out),队列是**先入先出**(first in first out)。

这章考代码的概率应远小于 **某表**。

### 插播一条概念

* 前驱和后继

**一个元素的前驱或后继实质上**指这个它的**前一个元素**和**后一个元素**。二叉排序树中要找一个元素的中序遍历前驱，就是要在小于它的元素中找最大的（就是找小于它的且**最靠近它的元素**）。中序遍历后继类似，不说了（关键字：大于，最靠近）。

## 第三章 串
只有一条好消息，**KMP算法**不考哦～，但防止万一，请记下它的算法**时间复杂度 O(M+N)**。


## 第四章 数组和广义表

广义表如果考的话应该也就考 **一个广义表的(深)度**了。数括号就行了。还可能

e.g.

* `(a,(a))` 深度是 **2**
* `(a,b,(a,(b,c)))` 是 **3**
* `(a,b,(a,(a,c,(d,e))),(x))` 是 **4**

* [这是关于广义表如何算长度和深度的传送门](http://zuoye
.baidu.com/question/138683737c1d72161a5d0cda8a916904.html)

* [这是关于head和tail的传送门(做试卷的应该都看过这俩名词)](http://zuoye.baidu.com/question/07abdcc3913d3a44e82b57db82fb1da8.html)

另外关于8号楼下数据结构期末题第一套的`数组题`

		将一个A[100][100]的三对角矩阵，按行优先存入一维数组B[298]中，数组下标从0开始编号，A中的元素A[65][64]再B中的位置K为_____。
		应填194，a[65][64]上面有64*3+2=194个元素。a[65][64]是第195个，而数组从0开始编号，所有B[194]存储了A[65][64]。

这里普及一下`三对角矩阵`，这就是三对角矩阵（4*4的）
![三对角矩阵](https://upload.wikimedia.org/math/e/b/c/ebc3ab5369e2fc1a1d2bb0dd68396027.png)

最左边的矩阵就是三对角矩阵
![big](https://upload.wikimedia.org/math/f/a/8/fa8a518330d0e8da1a0890bb2e587043.png)

## 第五章 树

树就考很多了，树的**前中后序遍历**你要是还不懂概念就快看书吧！！！！！~~这个遍历至少考5分以上。
~~哈夫曼树估计也是要考的，大概是**给定一个序列，然后构建一个哈夫曼树**。

树的遍历备考知识（说起来可能比较多，看不懂的去百度）

	给出先序遍历和后序遍历。输出这棵二叉树。
	1.先序的第一个是根a。
	2.先序序列 根的后一个节点b只可能是根的左右节点之一。
	3.如果中序中b出现在a之前，b是a的左儿子，反之是儿子。
	4.中序中a 左边的是a左子树的中序遍历，右边则是a右子树的中序遍历。
	5.第四点对所有假定的根都成立，递归得出这棵二叉树。
	
树、森林和二叉树的转换
[link(来源于cnblog)](http://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html)

怎么构建`哈夫曼树`？

	哈夫曼树的构造算法

	假设有n个权值，则构造出得哈夫曼树有n个叶子结点。n个权值分别设为w1,w2,...,wn,则哈夫曼树的构造规则为:

	(1)将w1,w2,...,wn看成是有n棵树的森林(每棵树仅有一个结点);
	(2)在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
	(3)从森林中删除选取的两棵树，并将新树加入森林;
	(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

结合上面的可以再看看下面的图解

* [又见哈夫曼树图解传送门，可是该门广告多](http://www.th7.cn/Program/c/201410/304813.shtml)
* 听说`可以停用**Javascript**屏蔽广告，懂了人以后都看不到广告了哈哈哈哈`

第六章 哈希表
--------------------

这章必考，大概就是类似ppt那样的考法
不会的去看书
 [我叫严蔚敏的数据结构pdf下载传送门](http://down5.cr173.com/soft1/shujujiegou.rar)

处理冲突的方法百度有介绍
[百度百科：哈希表](http://baike.baidu.com/link?url=Jz0q6Ewkh4qUNI6yBiQpuIbUCU5Rfllul1cxi0-26jil8BN_wUq-gERwI2-n48mPyxM6T46DKXy8uaMDV2MgnK)，直接翻到处理`冲突`的那一块看就好了，当然`构造`方法也得看看。

另外还有[平均查找长度的计算](http://blog.csdn.net/wangran51/article/details/8826633)，也是可能考的。

(友情提示：用CMCC-EDU的同学很可能打不开该链接，因为移动好像`墙`了csdn.net，据说github都被墙了)
第七章 图论
-----
这章你需要会**图的遍历**。还有一些基本概念比如说`结点的度`。

* [**队列实现bfs**](http://blueve.me/archives/417)
* [**dfs**](http://jingyan.baidu.com/article/00a07f38babf4182d028dca2.html)
* 实际上树也是一个图，树的先序中序后序遍历都是**深度优先遍历**
* 一般来说是用栈或者`队列`实现bfs,用`函数递归`实现dfs（**回溯法**的基本做法）。

###生成树


	　如果连通图G的一个子图是一棵包含G的所有顶点的树，则该子图称为G的生成树(SpanningTree)。
	　生成树是连通图的包含图中的所有顶点的极小连通子图。
	　图的生成树不惟一。从不同的顶点出发进行遍历，可以得到不同的生成树。

### 最小生成树
如何画最小生成树？

摘自 `百度知道`（原来百度知道里也是有有用的答案的Orz）

		1） 树是无回路的连通图。
		2）对于某个图，求它的最小生成树，比较简单的方法，先画出图中所有节点，从权值最小的边开始依次连接顶点，注意不要	形成回路，最后得到的图就是最小生成树。
		
第八章 二分查找
--------------------

* `谨记`二分查找的数据结构必须是`有序`的
* 假如是用`链式存储`数据，即使元素有序，我看你怎么`二分`（期末题第一套12.梗）

### 二叉排序树

* 中序遍历二叉排序树的结果必然是一个有序的序列（比如从小到大）

#### 如何构建二叉排序树？

百度百科是这么规定二叉排序树的
	
		二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
	（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
	（3）左、右子树也分别为二叉排序树；
	（4）没有键值相等的节点。

再给你看个二叉排序树的图
这是对序列`(8,3,10,1,6,4,14,7,13)` 建立二叉排序树的结果
![img](http://pic002.cnblogs.com/images/2012/457289/2012110918051618.jpg)

先把8作为根，然后3比8小，成为8的左儿子。10比8大，作为8的右儿子。1比8小，再比3小，作为3的左儿子....

如果还不懂就去看`严奶奶的书(diyu)`吧 23333333

第九章 排序
----------------

O(n^2)的排序就不说了，直接说O(n<sup>1.5</sup>)和O(nlogn)的

`希尔排序`O(n<sup>1.5</sup>)

* 希尔排序有一个关键的概念叫“步长”(gap)

* 建议到这里看[希尔排序](http://blog.csdn.net/morewindows/article/details/6668714)

迷之希尔排序只有4行代码

	void shellsort(int a[], int n){
		for (int gap = n / 2; gap > 0; gap /= 2)
			for (int i = gap; i < n; i++)
				for (int j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap)
					swap(a[j], a[j + gap]);//swap是交换的意思
	}

后面都是O(nlogn)的

`快速排序` 

快速排序简单吧，直接看老严的书你也能懂，不过代码优点难写，可是`老师肯定不考代码的啦`。

不过还是给的我自己写的？

	void quicksort(int a[],int l,int r){
		if(l<r){
		int ll = l , rr = r , cmp = a[l];
		while(ll<rr){
			while(ll<rr&&a[rr]>cmp)
				rr--;
			a[ll]=a[rr];
			while (ll<rr&&a[ll]<=cmp) {
				ll++;
			}
			a[rr]=a[ll];
		}
		a[ll]=cmp;
		quicksort(a,l, ll-1);
		quicksort(a,ll+1, r);
	}//咋一看连swap都没有，肯定有问题？不，你仔细看看这个代码，没有问题。


`归并排序`

归并排序是一种体现`分治思想`的排序算法，它是我们现在所学到的O(nlogn)算法里唯一一个排序`稳定`的算法。

* 这个我建议数据结构较好的去看`算法--C语言实现（第1～4部分）`这本书，当然你想挑战`老严的diyu`我也是十分`赞(fan)成(dui)`的，其他的可以去看，《大话数据结构》，当然你想挑战`老严的diyu`我就………………
* 还建议看[维基百科 归并排序](https://zh.wikipedia.org/zh-hk/归并排序)

顺便贴代码

	void mergeArray(int a[],int l,int mid,int r,int aux[]){
		int cnt;//index	  e.g. aux[cnt]
		int l1 = l,r1 =mid,l2 = mid + 1,r2 = r;
		for (cnt = l; cnt <=r; cnt++) {
			if(l1==r1+1) {aux[cnt]=a[l2++];continue;}
		if(l2==r2+1) {aux[cnt]=a[l1++];continue;}
		aux[cnt] = (a[l2] < a[l1]) ? a[l2++] : a[l1++] ;
		}
		for (int i = l; i<=r ;i++)
			a[i] = aux[i];
	}//归并两个给定数组 思想来自于《算法－－C语言》的"合并两个数组"

	void mergesort(int a[],int l,int r,int aux[]){
	if (l<r){
		int mid = (l + r) / 2;
		mergesort(a,l,mid,aux);
		mergesort(a,mid+1,r,aux);//递归分割
		mergeArray(a,l,mid,r,aux);//将有序数组归并
	}
	}

	bool Mergesort(int a[],int n){
		int *aux = (int *)malloc(sizeof(int)*n);//aux意思是辅助数组
		if(aux==NULL) return cout<<"error!"<<endl,false;
		mergesort(a,0,n-1,aux);
		free(aux);
		return true;
	}
	
## 堆排序

#### 学渣止步...这个排序可能有点难。

说到堆排序，首先要介绍一下`堆`的概念。

### 堆

定义一（堆有序的定义）:如果一棵树中每个节点的关键字都不小于所有子节点的`值，或者说是关键字`(如果子节点存在的话)，那么久称这棵树是`堆有序`的。同样的，一棵`堆有序`中节点的关键字小于等于那个父节点的关键字（如果父节点存在）。[^1]

定义二：**`堆`**是一个节点的集合，表示为`数组`，其中*关键字按照**堆有序**的**完全二叉树**的形式排列*。

性质一：若a是一个`小顶堆`，那么a[0]是堆中最小的元素。

定义一中的堆实际上是`小顶堆`，还有一个概念是`大顶堆`，这个在后面会有提到。

如何利用堆将一个数组从大到小排序呢？

#### 堆排序

* 堆排序的思想类似于选择排序，也是每次找到一个最大(小)的数，然后在其余的数里找到最大(小)的，只不过每次只需要log(n)次计算，而不是n。
* 大概就是先让其符合`小顶堆`的性质，也就是`堆化`，然后再fixdown n-1次,伪代码是这样的
* fixdown的意思是`自顶向下堆化`，MinFixdown(a,0,i)中，i是堆元素的数量，0表示从a[0]开始堆化，就是`堆化以i为结尾的a数组`！
* 下面给出`从大到小排序`的堆排 `算法`

		algorithm heapsort(a[],n){
			MakeMinHeap(a) % 堆化数组a a变为最小堆
			for i n-1->1  % swap后 a[0]~a[i]就不一定还是堆了！需要继续fixdown
				MinFixdown (a,0,i) % a[0]~a[i]视为一个(子)堆，fixdown这个(子)堆
				swap(a[0],a[i]) % fix后由堆的性质一可知a[0]是a[0]~a[i]里最小的，把找到的最小的，也就是a[0],放到最后面
			end 
		} %堆排序完成，排完序后 小顶堆被完全破坏 ，堆中

* 你们加油 [維基百科 堆排序](https://zh.wikipedia.org/zh-hk/堆排序)

* csdn博客里有一个白话算法系列，那里写的这个`堆排序`算法可以去看看，。

* 下方有个堆排动态图[^2]


下方是我整理的从大到小堆排的代码，代码出自上面那个blog。
首先是fixdown函数，从元素a[i]开始，n为数组上界

		void MinHeapFixDown(int a[],int i,int n){
			int j, temp;
			temp = a[i];
			j = 2 * i + 1;
			while (j < n)
			{
				if (j + 1 < n && a[j + 1] < a[j])
					j++;
				if (a[j] >= temp)
					break;
				a[i] = a[j];
				i = j;
				j = 2 * i + 1;
			}
			a[i] = temp;
		}

构建小顶堆

		void MakeMinHeap(int a[],int n){//自顶向下地构建小顶堆
			for (int i = n/2 - 1; i >= 0 ; i--)
				MinHeapFixDown(a, i, n);
		}

堆排序

		void heapsort(int a[], int n){
			MakeMinHeap(a,n);
			for (int i = n - 1; i >= 1; i--){
				MinHeapFixDown(a, 0, i);
				swap(a[i], a[0]);
				}
		}

swap函数

		inline void swap(int &a,int &b){//&是C++的特性，&是引用的意思，&类似于指针，但是作用比指针弱，该函数引用了a变量，这个函数里改变a变量是真的会改变传入的a的值的。（也就是a在函数里是是参）inline是内联函数的关键词，不用管它，只是为了加快速度
			int t=a;
			a = b;
			b = t;
		}


		
	
`关于这些排序的比较`

* (数据结构期末题第一套10.)一个序列，如果要找出最大的x个元素，则采用______。

	应该是`堆排序`。具体看《算法－－C语言实现》**P241图9-10及其下方的注解**。
	也可以看这个动态图 
	![img](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)

		这个图也可以帮你理解堆排序的原理。

* (数据结构期末题第一套15.) 

	`堆排序`，快排递归调用O(logn)的空间，归并固定O(n),堆排O(1)。堆排空间性能最好。
	
* (数据结构期末题第一套9.) 

	其实冒泡最省时间，因为冒泡在这个情况下是***O(n)***，而平均最快的快排却是***O(n<sup>2</sup>)***


* 快排平均最快，归并其次，堆排是O(nlogn)里最慢的


  

		
[^1]:《算法－－C语言实现》第1～4部分 9.2节
[^2]: 维基百科－－堆排序（繁体）
[^3]: 《算法导论》

