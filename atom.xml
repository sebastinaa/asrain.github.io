<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[wuyuhuan's blog]]></title>
  <subtitle><![CDATA[打的不错，我很抱歉。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://1013rain.me//"/>
  <updated>2016-03-13T15:40:31.000Z</updated>
  <id>http://1013rain.me//</id>
  
  <author>
    <name><![CDATA[Yuhuan Wu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[EVE古斯塔斯海盗四级任务]]></title>
    <link href="http://1013rain.me/2016/02/17/gsts-mission/"/>
    <id>http://1013rain.me/2016/02/17/gsts-mission/</id>
    <published>2016-02-17T15:36:04.000Z</published>
    <updated>2016-03-13T15:40:31.000Z</updated>
    <content type="html"><![CDATA[<p>2016年2月17日更新<br>BTA版古斯塔斯四级任务<br>有部分任务已不能速刷，我已修正攻略。</p>
<blockquote>
<p>另外，你最好使用<code>ctrl+f</code>寻找任务<br><a id="more"></a></p>
</blockquote>
<h2 id="无人机的袭击">无人机的袭击</h2><p>抗性：全抗<br>进去之后等一小会，会刷出来4个中型无人机，打掉其中一个距离最近的，会刷出来3巡洋级别3战列级别的无人机，清掉，完成任务。<br>注：应该打掉的是最近的那个怪，不固定是哪个名字<br>需要注意的是，一开始另外3个胜利者无人机不能打，打死了会刷另外3波怪，会让你很HIGH的</p>
<ul>
<li><strong>已改版，注意全清！！！！</strong></li>
</ul>
<h2 id="复仇之火">复仇之火</h2><p>莫德团，动动热<br>第一层按照距离顺序清<br>第二层暴动，留一个15KM的怪最后打方便拿任务物品，然后随便杀，BOSS比较硬，一般50KM环绕你<br>大约1个小时搞定.</p>
<h2 id="侦察">侦察</h2><p>1/3 开高速小船即可，直接过加速轨道(57KM)然后走人<br>2/3 开高速小船即可，接近左边的被加锁的加速轨道(77KM)，然后刷一堆怪，不管他们，跳走<br>3/3 开巡洋上个微曲即可，记得堆<strong>全抗</strong>，堆有效到2W以上。</p>
<h2 id="扎茨玛特的右使者">扎茨玛特的右使者</h2><p>应带抗性：动热全/动热热<br>应带弹药：动能/热能伤害<br><strong>快速打法：打哨站，打佐尔，捡佐尔的残骸，结束。</strong></p>
<h2 id="袭击">袭击</h2><p>加达里<br>动动热<br>全清，注意怪离得比较远，最好带个感应增强。<br>主要收益为加达里上将牌，吉他价500W/个。总共大约13个上将牌。</p>
<ul>
<li>这个任务扣大量加达里声望，推荐加达里永远的敌人做。</li>
</ul>
<h2 id="危难中的少女">危难中的少女</h2><p>抗性：全抗<br>先假跳50KM，先打掉2个护卫怪，然后打掉4个巡洋怪，再打掉3个战列怪，最后打克鲁乌尔。<br>打掉克鲁乌尔之后刷出来6条战列怪，依次干掉<br>然后把娱乐花园打到半甲，刷4条战列怪，4条巡洋怪，2个蜘蛛无人<br>然后把娱乐花园打到半结构，刷出佐尔等人，全部干掉<br>最后打掉娱乐花园，回去换打捞船来打捞。<br>佐尔会掉世界碰撞的加密卡，存着。</p>
<p><strong>快速打法：直接顶着火力打掉你右边的花园，捡含有少女的箱子，走人。如果你能顶火力打掉佐尔，请打掉佐尔并捡残骸。</strong></p>
<h2 id="莫德团的猎头">莫德团的猎头</h2><p>动动热<br>第一层：有一堆怪主动攻击，一堆被动<br>第二层：4堆怪，按距离打掉最近的3堆，任务完成<br>小怪超级多……蛋疼<br>1小时左右，最好带个大炸蛋。</p>
<h2 id="货柜递送">货柜递送</h2><p>高速护卫，进任务空间后直接开微曲冲仓库，拿到东西速度走人。</p>
<ul>
<li>刚开始做这个任务的时候最好带个中型盾扩。</li>
</ul>
<p>大约10秒。</p>
<h2 id="伏击护航队(艾玛任务)">伏击护航队(艾玛任务)</h2><p>动动热，天蛇怪<br>先干掉炮塔，那玩意DPS高<br>5巡洋2战列4运输，轻松抗住杀，记得留个近的牵引任务物品<br>我一般先干掉巡洋然后干掉战列最后打运输，这个时候运输基本上跑到你10KM以内了</p>
<h2 id="世界碰撞">世界碰撞</h2><p>艾玛怪 全抗<br>记得带上微曲<br>第一层：带上 打<strong>佐尔</strong>掉的<strong>毕克基的破译卡</strong> ，过<strong>劳工</strong>轨道<br>第二层：开微曲冲加速轨道，并打掉 <strong>劳工监督者</strong> 捡残骸，有几率爆势力装和脑插，劳工监督者的吨位会变化，当它是战列的时候爆的势力装是最贵的(大约7E)。<br>第三层：过轨道停船，然后打掉建筑<strong>军械库</strong>闪人</p>
<h2 id="无人机滋生的遗迹">无人机滋生的遗迹</h2><p>全抗<br>带个感应增强+锁定距离脚本<br>锁定次级机巢(约100KM)，打掉，任务完成</p>
<h2 id="阻止小偷">阻止小偷</h2><p>全抗<br>假跳70KM，先打巡洋舰，再打护卫舰，最后打战列舰<br>熟悉任务后，直接打掉战列怪，然后打掉“影”，闪人，买个报告回去交任务。</p>
<h2 id="疤痕">疤痕</h2><p>全抗<br>进去之后怪不会主动攻击，怪的智商都不拙计，不过速度很快。而且战列会帖你8KM，很方便<br>第一层：2个战列怪11个巡洋怪，14个护卫怪，轨道58KM，全清<br>第二层：4个战列怪11个巡洋怪，轨道42KM，全清<br>第三层：4个战列怪8个巡洋怪4个护卫怪（两个精英巡洋不用打），清完战列。<br>怪的伤害很复杂，建议堆全抗。</p>
<ul>
<li>主要战利品为 <code>共和舰队指挥官勋章I</code> 2000W一个。</li>
</ul>
<h2 id="抢救矿冶设施">抢救矿冶设施</h2><p>无人机<br>磁爆热抗<br>第一层：两批怪，其实可以直接拉暴动，1战列6巡洋6护卫，有一个加强型的可能会反跳或者网。先清掉战列和巡洋，然后放出轻无去爬轨道。<br>第二层：三堆怪，按距离顺序清掉2堆怪，然后打掉“无人机堡垒”即可，最远的80KM的那一波怪不用打。</p>
<h2 id="阻止军备">阻止军备</h2><p>加达里<br>动动热</p>
<p>先启动跃迁到任务空间前，然后取消跃迁，<strong>最少</strong>5分钟之后再进入这个任务干掉5条运输舰。<code>5分钟之后</code>是因为刷出运输舰要5分钟。<br>3个战列也可以打，掉加达里中将牌子，一个1500W。</p>
<ul>
<li>掉加达里声望2.4%</li>
</ul>
<h2 id="自由无人机的骚扰">自由无人机的骚扰</h2><p>爆热磁<br>第一层：<br>凯兹姆无人机母体，打几下刷一波怪<br>2/3甲，2护卫4巡洋<br>1/2甲，2护卫4巡洋<br>1/3甲，2护卫4巡洋<br>1/5甲，2护卫4巡洋<br>第二层：<br>2巡洋3战列，主动攻击</p>
<p>大约20分钟</p>
<h2 id="海盗的生意">海盗的生意</h2><p>艾玛，磁磁热抗<br>第一层：8护卫15巡洋5战列，按从近到远清吧，轨道73KM<br>第二层：14护卫20巡洋6战列，按照从近到远清。最后留个近的捡任务物品<br>大约55分钟</p>
<h2 id="未授权的军队">未授权的军队</h2><p>加达里<br>动动热<br>第一层：5巡洋2护卫，轨道20KM，没锁，直接进。<br>第二层：6战列，很多巡洋和护卫，全清之。其实可以只打最远的那波怪。然后把所有战列怪清掉拿牌子。<br>大约20分钟</p>
<ul>
<li>掉加达里声望2.4%</li>
</ul>
<h2 id="惊奇">惊奇</h2><p>艾玛+加达里<br>动热磁<br>先干掉运输舰，然后打掉最远的那个皇家塔那柯，105KM的位置的。然后再干掉100KM位置的合众国天宫，也就是最近的那个，任务完成。<br>好嘛其实合众国的牌子很值钱，任务完成之后我把剩下的2个合众国的战列怪也打掉了。那牌子400W一个<br>注意，运输舰经常以1400M/S的速度逃跑，要赶快锁定它。<br>大约20分钟</p>
<h2 id="海军舰队">海军舰队</h2><p>加达里<br>动动热<br>加达里海军，牌子很值钱<br>主要伤害是鞭挞导弹，动动热<br>第一层轨道77KM<br>6战列9巡洋2护卫<br>二层轨道64KM<br>9战列9巡洋2护卫，后来又刷新1战列2护卫<br>三层<br>全清<br>总共是20个中将牌子5个上将牌子，约3E ISK。</p>
<ul>
<li>有人说他双开15分钟完成（魔像+响尾蛇），我恶狼+响尾蛇是25分钟完成。</li>
</ul>
<h2 id="死人不会说话">死人不会说话</h2><p>全抗<br>第一层：无人机怪 分成3堆 一堆2战列 一堆3战列 一堆6巡洋<br>进去别打炮台，先打战列怪，打炮台会暴动<br>第二层：雇佣兵怪 先打主动攻击怪，然后按照距离顺序清<br>第三层：打掉BOSS结束<br>大约40分钟</p>
<h2 id="狂暴">狂暴</h2><p>应带抗性：动热全/动动热<br>应带弹药：动能伤害<br>快速打法：此任务为开放空间，跳任务点0M，可以看到一个象雷达站一样的建筑，面对该建筑刷出左、中、右三批怪，分别为1九头蛇1十字军，直接打最右边的十字军，会刷出2个死亡骑士，继续打刷出的死亡骑士，会在雷达站左侧刷出1个单独的九头蛇，杀之，然后又刷1个新的九头蛇和1个食人魔，杀掉食人魔，会刷出1个死亡大帝，杀掉这个死亡大帝任务就结束了。<br>全灭打法：按照上面的顺序杀完3批即可，如果觉得自己完全能顶，火力强大可以随意的杀。<br>主要利润：全灭的话ISK大概1100W左右，EOM怪的残骸打捞不怎么好但是垃圾很不错，衍生4的炮和架子都可能有。<br>注意事项：对于第一次做这个任务的人来说，千万不要被EOM怪A船的外型蒙骗了，其实全都是动能伤害的攻击</p>
<h2 id="进化">进化</h2><p>故事线<br>无人机怪<br>磁热爆抗<br>带上感应增强+锁定距离脚本<br>打掉被寄生的空间站，打掉反跳的无人机，立马闪人。<br>有能量中和塔，不管他。</p>
<h2 id="截击破坏者">截击破坏者</h2><p>艾玛<br>磁磁热<br>第一层：5个护卫<br>第二层：21个护卫3运输舰15巡洋3战列，分3堆，均为被动<br>最左边一堆不用管，把3个艾玛运输舰所在的一堆打掉就好<br>20分钟 7660LP</p>
<h2 id="羊入虎口">羊入虎口</h2><p>故事线<br>古斯塔斯怪 动动热<br>有一条渡神，2条乌鸦3条茶隼<br>好吧那渡神是结构抗，非常难啃<br>渡神打掉之后又刷出2乌鸦3茶隼，一共是4乌鸦6茶隼<br>按照从大到小打掉之后，又刷新了6只乌鸦5只巨鸟。<br>按照从大到小打掉之后，又刷新了4乌鸦2猛鲑，其中有一个怪叫：古斯塔斯官员……好囧<br>我很奇怪，怪都是古斯塔斯的，明明是自己人啊。</p>
<h2 id="清除记录">清除记录</h2><p>故事线<br>雇佣兵怪，全抗，我带的是动热爆<br>进去之后2条轨道<br>通向酸性云团的轨道：和侦察3/3差不多，别走这边<br>通向巡逻区的轨道：<br>7小马，雇佣兵怪，动热全抗，暴动<br>第二层：<br>6小马，其中3主动3被动，另外6巡洋舰怪，3主动3被动，2护卫主动</p>
<h1 id="故事线">故事线</h1><p>做四级战斗故事线的好处是可以快速提升到势力5的声望。势力声望到5就可以基本无限拒任务（只要代理人声望和军团声望高于-2就可以拒）。坏处是你GSTS势力声望到5，C族A族你也估计永远去不了了。<br>故事线我没做过，仅供参考。（因为我以后肯定要走高安）</p>
<h2 id="暗杀企图">暗杀企图</h2><p>故事线<br>加达里<br>动动热<br>BOSS是爆炸伤害的星爆鱼雷<br>4炮台先打掉，然后打掉3毒蝎1BOSS，4护卫最后留一个可以养任务，不过BOSS似乎不掉势力装备</p>
<h2 id="收服打捞能手(+11-5%_GSTS声望)">收服打捞能手(+11.5% GSTS声望)</h2><p>故事线</p>
<p>无人机怪，代理人还说是血袭者，这个骗子<br>记得带全抗<br>进去之后5战列3巡洋3护卫（战列是2皇后2女祭司1主教），灭之<br>3个任务箱子名字叫：科考船残骸，相互距离40KM，最好带个加力或者微曲<br>接近箱子12KM时会刷3战列3巡洋</p>
<h2 id="斯库维塔事件6/6">斯库维塔事件6/6</h2><p>故事线</p>
<p>1/6掠夺那些电子产品<br>雇佣兵+加达里怪，动动热<br>一小马，三巨鸟，三护卫<br>三工业<br>进去后暴动，距离10KM以内<br>打掉最后一个怪之后掉一个箱子，里面有任务物品，4000立方<br>2/6新醇岩矿<br>加达里怪<br>动动热<br>10乌鸦6巨鸟4护卫3工业<br>火力很猛，我跳走一次才搞定<br>也可以直接打掉3工业，捡东西走人，不过加达里的牌子很值钱，10个乌鸦掉了30个上将牌子<br>3/6<br>快递新醇岩矿到H-P去<br>4/6防御姿态<br>10个炮塔1乌鸦2巨鸟<br>炮塔火力很猛，不过也很脆，先干掉<br>或者直接打掉三个怪完成任务<br>第二层不用进即可完成任务<br>第二层是6战列7巡洋6护卫，其中有一个巡洋BOSS<br>5/6加达里海军执事<br>动动热 加达里怪<br>两堆怪，一堆主动一堆被动<br>主动怪：3战列（1乌鸦2毒蝎）8护卫<br>被动怪：3战列（打掉BOSS即完成）6巨鸟6护卫<br>6/6星座扫描仪<br>动动热 加达里怪，雇佣兵怪<br>加速轨道均为0米<br>第一层：<br>被动，三堆怪，最近的一堆60KM，5护卫6巡洋3战列，加达里怪；第二堆2战列5巡洋，加达里怪；第三堆3护卫2战列，雇佣兵怪<br>按距离顺序清<br>第二层：<br>被动，三堆怪，最近的一堆40KM，4护卫5巡洋2战列，加达里怪；第二堆3战列6护卫，加达里怪；第三堆11护卫，加达里怪<br>第三层：<br>一堆主动一堆被动<br>主动怪有3个网怪，6巡洋5战列，火力很强，我被打到结构，差点跪了<br>进来先拉速度打掉网怪，然后打掉巡洋怪，最后打战列<br>被动怪有9护卫，1巡洋BOSS和1乌鸦BOSS，5战列（3乌鸦2小马）<br>先打掉护卫怪，然后打掉小马，最后打乌鸦<br>乌鸦BOSS掉各种海军装备，而且只要最后不打建筑就可以养7天</p>
<h2 id="诺门的主张">诺门的主张</h2><p>故事线<br>共5步<br>雇佣兵怪+艾玛怪<br>第一步，雇佣兵怪应该带爆动热抗<br>第一层： 三堆怪，最近的一堆怪主动攻击，伤害很高，我跳走1次才搞定 最近的第一队主动怪：6巡洋17KM环绕，6巡洋2KM环绕，5护卫7KM环绕 其他两队怪比较远，另外有4小马和10巡洋6护卫，基本上不用担心<br>第二层：3炮台3小马5巡洋3护卫，主动，差点扛不住。全灭之，然后打掉建筑，任务完成</p>
<p>第二步：快递，去H-P拿个东西</p>
<p>第三步：磁磁热抗 打艾玛怪，简单就抗住了，全灭即可，牌子要拿 3战列6巡洋6护卫</p>
<p>第四步：磁磁热抗<br>第一层：分4堆，第一堆3战列，第二堆5护卫1战列5巡洋，第三堆2战列4护卫3巡洋，第四堆3战列5巡洋4护卫。按照距离清即可，轻松搞定<br>第二层：一进去怪距离就1KM，还好远处的没暴动，按照距离慢慢清吧。 第一堆距离0米，主动，4护卫5巡洋2战列，1巡洋BOSS，出各种3%插头 第二堆距离40KM，被动，6护卫6巡洋2战列<br>补充一点：帝国海军 甲卡尔级战列舰居然带鞭挞巡航导弹，囧死我了</p>
<p>第五步：磁磁热抗+全抗 艾玛怪+雇佣兵怪<br>第一层：艾玛怪主动，艾玛+诺门怪被动 第一堆：艾玛怪，主动；4护卫会反跳网8巡洋1战列，距离0米 第二堆：诺门怪，3小马8狞獾，距离30KM 艾玛怪，5护卫2战列，距离30KM<br>第二层：艾玛怪，分四堆 第一堆：艾玛怪，3蜘蛛护卫4巡洋，主动 第二堆：艾玛怪，3战列，甲卡尔（丫居然带鞭挞巡航，我曰） 第三堆：艾玛怪，3战列5护卫<br>第三层：艾玛怪，4炮台6巡洋3护卫，3BOSS 主动怪，似乎不能养了，打掉小BOSS就完成了</p>
<h1 id="GSTS史诗任务">GSTS史诗任务</h1><p>GSTS史诗任务据我所知，塔洛斯有空间代理人可以接到该任务（名字应该叫古斯塔斯招募中心）。<br>如果你GSTS势力声望超过-2,那么可以去H-PA29的2号空间站的剧情代理人接到该任务。<br>整个任务进行只在K3JR，H-PA29，6NJ8，PF-QHK附近，也就是不出维纳尔。<br>任务主要收益为+35%势力声望（-10声望直接提到-3，有外交学或犯罪关系学可以直接开始做4级任务），一张研究过的毒蜥图，一个恐惧古斯塔斯多普ECM。</p>
<ul>
<li>完成最后一部任务，你将获得35% GSTS势力声望，但如果你在舰队里且完成任务时选择了平分报酬的话，<strong>这个声望会平分给你舰队的每一个人，比如舰队2人就是各得17.5%。</strong></li>
</ul>
<p>任务耗时约3小时，最好使用T3驱逐，势力/T2护卫也可，小心敌对可能来抓你。另外不要用巡洋，巡洋无法进入轨道。</p>
<ul>
<li>做任务的时候最好细读任务描述，而且毕竟是史诗任务，有很多剧情，比如用穿梭机撞死航母…</li>
</ul>
<p>你开始会在H-PA29附近做任务，接着会去PF-QHK附近，然后去6NJ8和K3JR（BTA控制）附近，最后在PF-QHK附近完成该史诗任务。去的最危险的地方在PVVL一跳位，高几率会有敌对抓你，不建议晚上做。建议挑一个早上1小时就能完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2016年2月17日更新<br>BTA版古斯塔斯四级任务<br>有部分任务已不能速刷，我已修正攻略。</p>
<blockquote>
<p>另外，你最好使用<code>ctrl+f</code>寻找任务<br>]]>
    
    </summary>
    
      <category term="EVE" scheme="http://1013rain.me/tags/EVE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LaTex基础教程（新人向）]]></title>
    <link href="http://1013rain.me/2016/02/10/page/"/>
    <id>http://1013rain.me/2016/02/10/page/</id>
    <published>2016-02-10T15:27:27.000Z</published>
    <updated>2016-03-13T15:43:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="没事来写个数模美赛LaTex教程">没事来写个数模美赛LaTex教程</h1><p>参加数模的美赛，LaTex基本上来说是必备的，而对于写作的来说直接对着教程学习LaTex可能有些难度（于是我在参加美赛的时候，作为一个编程狗最后一天全程排版）。故想写一个LaTex（仅限美赛）来解救猿/媛们。</p>
<p>此教程为<strong>纯新人向</strong>/面向写作。其实是因为自己只是个菜鸡，所以只能写出新人向的。</p>
<ul>
<li><strong>我还没写完</strong></li>
</ul>
<a id="more"></a>
<h1 id="你首先需要准备的">你首先需要准备的</h1><h2 id="软件">软件</h2><p>如果<del>你是Windows系统</del>你不是水果本，那么你需要<strong>下载</strong>下面的这个软件：</p>
<ul>
<li>CTex 2.9.2.164版本，<a href="http://kuai.xunlei.com/d/EGJNLIGKXSGQ" target="_blank" rel="external">迅雷快传下载</a> 或者 <a href="http://pan.baidu.com/s/11DhKi" target="_blank" rel="external">百度网盘下载</a></li>
</ul>
<p>下载完后，双击<code>CTeX_2.9.2.164_Full.exe</code>来安装（就是那个最大的文件），安装时请<strong>安装所有的组件</strong>。</p>
<p>如果你是水果本（Mac OS X)，那么你需要</p>
<ul>
<li>MacTex-2015，<a href="http://tug.org/cgi-bin/mactex-download/MacTeX.pkg" target="_blank" rel="external">官方下载</a></li>
</ul>
<p>注意，如果你的本子是最新系统(EI Capitan)，请在安装完后打开<code>TexShop</code>检查更新再更新它，否则有概率出错，原因的话英文屌的可以看这个<a href="http://www.tug.org/mactex/elcapitan.html" target="_blank" rel="external">传送门</a>。</p>
<p>所有的软件都可以在<a href="rs.xidian.edu.cn">睿思</a>中下载，前提是你得在学校。</p>
<h2 id="你需要一个模板">你需要一个模板</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="command">\documentclass</span><span class="special">[</span>a4paper, 11pt<span class="special">]</span><span class="special">&#123;</span>article<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- Loading the Package MCMthesis -----</span></span><br><span class="line"><span class="comment">% -----           v 5.01-L            -----</span></span><br><span class="line"><span class="comment">% `tcn' is short for `Team Control Number'.</span></span><br><span class="line"><span class="comment">% You should fill your tcn after the equal sign following tcn.</span></span><br><span class="line"><span class="comment">% The option `sheet' contorls weather the summary sheet</span></span><br><span class="line"><span class="comment">% will appear.</span></span><br><span class="line"><span class="comment">% The option `abstract' controls weather the abstract</span></span><br><span class="line"><span class="comment">% will appear in the title-page.</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">[</span>tcn = 12345, sheet = true, abstract = true<span class="special">]</span><span class="special">&#123;</span>main<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- Question Mark -----</span></span><br><span class="line"><span class="command">\problem</span><span class="special">&#123;</span>D<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- Fonts settings -----</span></span><br><span class="line"><span class="comment">% You may need to install the font files, if it's needed.</span></span><br><span class="line"><span class="comment">% Disable it, if you don't want this font.</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>palatino<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>makecell<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>indentfirst<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>shorttoc<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>amsmath<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>subfigure<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- Set the skip betweent the paragraphics -----</span></span><br><span class="line"><span class="command">\setlength</span><span class="command">\parskip</span><span class="special">&#123;</span>.5<span class="command">\baselineskip</span><span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- The name of Abstract ------</span></span><br><span class="line"><span class="command">\providecommand</span><span class="special">&#123;</span><span class="command">\abstractname</span><span class="special">&#125;</span><span class="special">&#123;</span><span class="command">\relax</span><span class="special">&#125;</span> <span class="comment">% &lt;-- Do not modify here.</span></span><br><span class="line"><span class="command">\renewcommand</span><span class="special">&#123;</span><span class="command">\abstractname</span><span class="special">&#125;</span><span class="special">&#123;</span>Summary<span class="special">&#125;</span> <span class="comment">% &lt;-- Modify here, if needed.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% -----------------------------------</span></span><br><span class="line"><span class="comment">% ===== The Title of Your Paper =====</span></span><br><span class="line"><span class="comment">% -----------------------------------</span></span><br><span class="line"><span class="command">\title</span><span class="special">&#123;</span>Your Title<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ---------------------------------------</span></span><br><span class="line"><span class="comment">% ===== The Author(s) of Your Paper =====</span></span><br><span class="line"><span class="comment">% ---------------------------------------</span></span><br><span class="line"><span class="comment">%\author&#123;\small \href&#123;http://www.latexstudio.net/&#125;&#123;\includegraphics[width=7cm]&#123;logo&#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">% ----------------</span></span><br><span class="line"><span class="comment">% ===== Time =====</span></span><br><span class="line"><span class="comment">% ----------------</span></span><br><span class="line"><span class="command">\date</span><span class="special">&#123;</span><span class="command">\today</span><span class="special">&#125;</span></span><br><span class="line"><span class="command">\begin</span><span class="special">&#123;</span>document<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% Abstract should be put before `\maketitle'</span></span><br><span class="line"><span class="command">\begin</span><span class="special">&#123;</span>abstract<span class="special">&#125;</span></span><br><span class="line"></span><br><span class="line">Begin your abstract.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">.<span class="command">\\</span></span><br><span class="line"><span class="command">\textbf</span><span class="special">&#123;</span>Key Words:<span class="special">&#125;</span> First; Second; Third</span><br><span class="line"></span><br><span class="line"><span class="command">\end</span><span class="special">&#123;</span>abstract<span class="special">&#125;</span></span><br><span class="line"><span class="command">\maketitle</span></span><br><span class="line"><span class="command">\thispagestyle</span><span class="special">&#123;</span>empty<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% Generate the Table of Contents, if it's needed.</span></span><br><span class="line"><span class="comment">%\tableofcontents</span></span><br><span class="line"><span class="comment">%\shorttableofcontents&#123;Contents&#125;&#123;2&#125;</span></span><br><span class="line"><span class="command">\newpage</span></span><br><span class="line"><span class="command">\pagestyle</span><span class="special">&#123;</span>fancy<span class="special">&#125;</span></span><br><span class="line"><span class="command">\pagenumbering</span><span class="special">&#123;</span>arabic<span class="special">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="command">\tableofcontents</span> <span class="comment">%make contents</span></span><br><span class="line"><span class="command">\newpage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% The body of your paper</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% Start References</span></span><br><span class="line"><span class="command">\addcontentsline</span><span class="special">&#123;</span>toc<span class="special">&#125;</span><span class="special">&#123;</span>section<span class="special">&#125;</span><span class="special">&#123;</span>References<span class="special">&#125;</span></span><br><span class="line"><span class="command">\bibliography</span><span class="special">&#123;</span>References<span class="special">&#125;</span><span class="command">\begin</span><span class="special">&#123;</span>thebibliography<span class="special">&#125;</span><span class="special">&#123;</span>99<span class="special">&#125;</span></span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>chuanranbing<span class="special">&#125;</span>Epidemic model.  https://en.wikipedia.org/wiki/Epidemic<span class="command">\_</span>modelequations </span><br><span class="line">dissemination<span class="special">[</span>D<span class="special">]</span>, University of Science and Technology of China. </span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>weiji<span class="special">&#125;</span>Le Zhang, Research on social network structure and dynamics of crisis information </span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>Index<span class="special">&#125;</span>Baidu Index. http://index.baidu.com </span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>PageRank<span class="special">&#125;</span>PageRank, Wikipedia. https://en.wikipedia.org/wiki/PageRank</span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>Mon<span class="special">&#125;</span>Quint Randle, A Historical Overview of the Effects of New Mass Media Introductions on Magazine Publishing During the 20th Century. http://firstmonday.org/article/view/885/794 </span><br><span class="line"><span class="command">\bibitem</span><span class="special">&#123;</span>Logit<span class="special">&#125;</span>The Logit function. https://en.wikipedia.org/wiki/Logit</span><br><span class="line"><span class="comment">%E2%80%93diffusion_system26/01/2016</span></span><br><span class="line"><span class="command">\end</span><span class="special">&#123;</span>thebibliography<span class="special">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="command">\end</span><span class="special">&#123;</span>document<span class="special">&#125;</span></span><br><span class="line"><span class="comment">% ----- End of Document Body -----</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="没事来写个数模美赛LaTex教程">没事来写个数模美赛LaTex教程</h1><p>参加数模的美赛，LaTex基本上来说是必备的，而对于写作的来说直接对着教程学习LaTex可能有些难度（于是我在参加美赛的时候，作为一个编程狗最后一天全程排版）。故想写一个LaTex（仅限美赛）来解救猿/媛们。</p>
<p>此教程为<strong>纯新人向</strong>/面向写作。其实是因为自己只是个菜鸡，所以只能写出新人向的。</p>
<ul>
<li><strong>我还没写完</strong></li>
</ul>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的数模国赛经历]]></title>
    <link href="http://1013rain.me/2015/12/30/CUMCMexp/"/>
    <id>http://1013rain.me/2015/12/30/CUMCMexp/</id>
    <published>2015-12-30T03:28:47.000Z</published>
    <updated>2016-01-06T03:42:33.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>去年12月份（2015.12），去成都参加完了数模国赛的颁奖典礼后，我的数模“生涯”终于告了一段落。</p>
<h2 id="<!-more->"><a id="more"></a></h2><h2 id="“结识”数模">“结识”数模</h2><p>记得第一次知道数模还是在大一上学期，快要结束的时候，那时候的我什么都不知道，就如同一张白纸一样。只是参加了一些讲座，听着讲座的老师讲数模，以及数模带来的一些好处。我那时大概知道了，数模是一个挺高大上的比赛，还有很多福利，而且选拔还挺严格，大概是神牛们的竞赛吧。</p>
<h2 id="准(wei)备(guan)数模">准(wei)备(guan)数模</h2><p>因为参加了那次讲座的缘故，使我对数学建模这个竞赛充满了好奇，然后讲座上的老师说数模竞赛要用MATLAB编程，于是我寒假就带回了点MATLAB的书，也去网上搜索了一些教程，偶尔学习一下。刚好有一位以前同寝室的室友找上我，问我要不要一起组一个队，和班上的女神一起，准备去打校赛。我感觉2位室友都很靠谱，于是就同意了。</p>
<p>也多亏了寒假时<a href="http://web.xidian.edu.cn/yfli/" target="_blank" rel="external"><strong>李隐峰老师</strong></a>邀请我进入他的实验室学习，下学期回来的时候找这个实验室的一位学姐了解了下数模以及校赛的情况（现在这位学姐已经去北大了，膜拜一下），给我推荐了一些书籍（比如MATLAB智能算法手册啥啥的），我也抽空看了一下。</p>
<h2 id="五一校赛">五一校赛</h2><p>5.1我还有我的室友，还有女神，放弃了这三天假期，参加了这一次五一校赛。校赛整体上还是很顺利的，我们在一起讨论题目，第一天上午确定了选做B题，下午查找了一些知网上的文献确定了第一问的模型，第二天搞定了第一问和第二问，第三天晚上9点完成了第三问和论文。</p>
<p>在这个过程中，三人都贡献了自己的力量，我主要负责建模还有编程，室友还有女神主要负责写作，不得不说女神的Word用的真心不错，而且学习能力也很强，一教就会，非常聪明。室友也很不错，自己搞定了第三问，而且在模型上也提出了很多的意见。尽管中间有段时间出现了问题，但是我们能够从容面对，然后kill它。</p>
<p>五一校赛，我觉得这是我上大学以来第一件做得最有意义的事情。在这三天里，我和我的队友们共同坐在一起，耐心地、集中精力去花费三天三夜的时间去解决一个实际问题，无论有没有获奖，这都是一件有意义的事情，也是一次珍贵的经验。</p>
<p>最后，更加令我惊讶的是，一个月后我们得知结果是校级一等奖，我当时的感觉就是<code>“It&#39;s unbelievable!”</code> 但事实就是如此。我的队友也是十分惊讶，我check了三四遍，确定了那个队伍就是我们。惊讶后是喜悦。这个一等奖也是对我们三天的劳动的一种承认。</p>
<p>也是这次校赛，带给了我信心，因为这次校赛，才有了接下来的故事。</p>
<h2 id="国赛前">国赛前</h2><h3 id="国赛培训第一阶段">国赛培训第一阶段</h3><p>校赛拿了一等奖，这个奖让我有了去参加国赛的想法。可惜，因为两位队友都没有在暑假留校的想法，我只能一个人去参加国赛的培训，然后寻找两位合适的队友来参加国赛。</p>
<p>开始培训的前几天，一位学姐找上了我，问我要不要和她们一起组队。然后我和她聊了一聊，发现队伍里一个人叫高捷，我当时记得高捷是和我同一个俱乐部的，想想这样应该可以很快地融入进去，加上高捷当时写作的排名很高，而且这位叫甄烨的学姐建模排名也很高，于是我就加入了她们。</p>
<p>我们的培训分为两个阶段，第一个阶段是老师讲课，讲一些<strong>经典模型</strong>，比如讲马尔科夫链、排队论、动态规划、模糊数学、灰色预测之类的，然后会有课后作业；第二阶段是模拟训练。</p>
<p>第一个培训阶段，无论是甄烨（建模），高捷（写作），我（编程），都是全力以赴，每次作业都是认真完成。可是队伍还是出现了不少问题，在这里我引用一下刘辽学姐关于组队的一些看法，她这里说的句句是真理啊：</p>
<blockquote>
<ul>
<li><p>挑选队友的时候要结合自身情况综合考虑，寻找最适合自己的。水平最高的其实不一定是最适合自己的。比如说你很粗心不注重细节，队友最好就要细心一些，把细节都把握好。最好三人可以各有所长，优势互补。</p>
</li>
<li><p>多从自身找原因，避免频繁换队友。很多队伍在前期培训的时候或多或少会出现矛盾和摩擦，可能有些同学就会对自己的队友意见很大，拆队重组。客观的说确实有些是真的不合适，但大部分人是由于心态过于浮躁。遇到问题要多从自身找找原因，是不是自己很多方面没有做到位，换队友不仅劳神费心，面子上也过不太去，最重要的是换了之后可能还不如原来的。我们队就相处的很和谐，有问题就提出来，觉得对方哪里做的不好就让他改正，从来没有说过要换队友。多磨合磨合吧，说不定你的队友是潜力股，有着意想不到的惊喜~</p>
</li>
</ul>
<ul>
<li>先下手为强。如果等到老师说组队的时候再开始找队友，可能好的潜力股都被别人预定喽~我就深谙这个道理，所以早早地就预定了陈映宇童鞋。在前期培训的时候，就可以找队友了，通过自己的观察和打听，寻觅好适合自己的队友，提前联系，这样就可以避免自己中意的队友被别人早一步组队的情况。</li>
</ul>
<ul>
<li>强强联合是王道。大神也需要大神队友，强强联合才能多一份胜算，学会推销自己，尽量为自己找到优秀的队友，最起码和自己水平差不多，不能太过悬殊。</li>
</ul>
</blockquote>
<p>第一阶段的培训圆满结束，我感觉无论是建模的甄烨还是写作的高捷都很认真，每次我们写老师留下来的作业都是写到1点多，高捷的写作很棒，一次成型，我根本挑不出什么问题出来，但是甄烨每次都能抓出作业的论文里的每一个小问题（可以说国赛结果的一大部分功劳可以归于修改论文的甄烨）。不得不说第一阶段的培训十分得辛苦，上文也说到了每次训练后写留下来的作业都得写到1点多，而且还是以<strong>在上课中已经大概明白理论的基础下</strong>写到得一点多。</p>
<p>辛苦但<strong>值得</strong>，因为我们三人都在这第一次培训中成长了太多，首先就是数模所需要的经典模型我们都基本上已经掌握完全了，其次是三人负责的方向更加精通了，三人的配合也更加默契，也大概知道了相互的脾气和习惯（甄妈妈，本宝宝~~，轻黑一波，两位队友看到不要介意喔）。也因为我们在第一阶段中严格要求自己（每次都要求完整做完，而且要求论文不能水水就过），我们在第二阶段的培训走得挺顺利的，这也给我们冲击国赛增添了一些信心。</p>
<h3 id="国赛培训第二阶段">国赛培训第二阶段</h3><p>到了第二阶段，就是真刀真枪做国赛题了。在第二阶段之前，我们得找老师，也许是运气问题，我们成功找到了韩邦合老师来带我们第二阶段的培训。韩老师是一个说话很直接的人，但他也是老师中最负责任的老师之一，可以说成为他的学生是一种福气。可以说如果没有韩老师在国赛前培训的认真辅导，我们很难在国赛中拿到好的成绩。在这里也非常感谢韩老师。</p>
<p>第二阶段就是模拟国赛，我们一共做了3套题，一套是西工大的校赛题，插值与拟合的，这个题比较简单，因为是一个校级别的，就是一个三维的插值。第二题是抗压题，研究生建模竞赛国赛得B题，关于目标跟踪的题目，核心是<a href="https://zh.wikipedia.org/wiki/卡尔曼滤波" target="_blank" rel="external">卡尔曼滤波</a>，这道题很难，因为涉及的内容专业性比较强，但是我们最终还是熬夜把论文赶出来了（做完这道题后，我们觉得自己的抗压能力有了极大的提升，至少国赛得题再难也不会做不完了）。第三题是2012年国赛B题，太阳能小屋设计，一道很开放的题，不是很难。</p>
<p>感觉第二阶段过去了，我们队伍做题形成了自己的分工模式，我专门负责编程以及对模型的一些建议，甄烨负责模型的总体建立和方向以及论文的修改，高捷则负责论文的撰写（及其高速而有效地撰写）。我们做题也形成了一个套路，就是第一天基本上能确定第一问得模型，第二天早上就开始编程并开始第二问得建模，论文的撰写也在同步进行，第三天搞定二三问，写完论文及修改。如此迅速的做题进度是离不开我们三人的默契配合的。<br><img src="http://math.xidian.edu.cn/kindeditor-4.1.10/attached/image/20151126/20151126094129262926.jpg" alt="presentation"></p>
<h2 id="国赛进行时">国赛进行时</h2><p>第二阶段的培训结束2天后，我们就参加了国赛。国赛前一天，我好好地睡了一个觉，8点起睡，因为明天的8点开始就是国赛了，国赛注定要熬夜，先让自己精力充沛地迎接国赛的开始。</p>
<p>国赛上午8点，我和我的队友们早早到达了实验室，打开了属于自己的电脑，坐在面前盯着屏幕，等待着题目的发布。题目发布后，经过再三斟酌我们决定选择B题，虽然A题的太阳影子定位的第一问很简单，但是A题是属于一道难度递增的题目，而且第二问就奇难无比（事实上很多人第二天都卡在了第二问上），第四问还需要处理一个视频，提取视频里影子的数据。而B题，出租车打车资源配置研究，则是一道难度递减的题目。B题的第一问就很难了。最重要的时，B题的数据需要自己去搜索！！！这就是B题最难的地方，找到了数据才能建模啊，不然建模建出来了数据根本找不到，结果跑不出来也没啥用了。比较两题，难度都差不多，一个是开始简单逐渐变难，一个是开始难后来简单。我们又比对了一下，B题是一个<strong>开放题</strong>，它是没有标准答案的（和14年、12年的B题一样），而A题需要保证自己结果的准确度，如果答案是湖南长沙你算到的点都在美国或者北冰洋会是怎样的一种<strong>体验</strong>？</p>
<p>所以最终选择了B题，一路坎坷，我们在<strong>第二天下午</strong>才确定了数据，确定数据后我们火速前进，我用C和MATLAB处理数据，甄烨迅速建完第一问和第二问的模型，高捷顺着我们的思路写第一二问，到了第二天的晚上我们把模型建完，想想第一天到第二天其中<strong>因为找不到数据和建模没有头绪</strong>还有一次换题的想法（建模的甄烨和我当时觉得B题没法做，决定换题，最终写作的坚持到底，就没换，感谢她的坚持），还好坚持了下来。在第二天晚上熬夜把第一问做完，第一问一完，后两问就成了小CASE，被我们用半天时间推下，高捷的论文写作速度也是快得飞起，晚上8点就写完了论文，于是最后的第三天下午加晚上就用来修改论文。</p>
<p>到了第四天的凌晨，我把模型的图重整了一遍，甄烨查错，高捷写摘要，各司其职，到了第四天的6点半左右，我们终于把论文改完，摘要修改完毕（摘要大概将近3个多钟头，摘要是论文的眼睛，别人看论文第一看的就是摘要，摘要如果写的不好后面基本上也就白写了），这时离交卷还有1个半钟头。</p>
<p>因为网络堵塞的问题，我们在9点交了卷，交论文的那一刻，虽然已经熬夜了2天，但我是激动的和喜悦的，暑假将近2个月的假期投入到了数模里，这篇论文也是我们3人一个暑假的成果，也给我们的暑假数模画上了一个句号。</p>
<p>交完卷，收拾了会儿东西，和队友离开了实验室，然后回去补了一天的觉，什么也不想，也没有想过拿什么奖，直接就睡到了次日的10点。</p>
<h2 id="国赛后">国赛后</h2><p>国赛后的日子还是如同往常一样，寝室-教学楼-图书馆三点一线。可是2个星期后听到了组里有个队被通知了答辩，我的心一下子紧了起来，因为听说去答辩的都基本上是国奖。我期盼着能被抽到，谁不想拿个大奖呢？可是答辩的通知杳无音讯，十一的时候去参加一个英语的口语特训营碰上了大辽学姐，问到她也没有收到通知，相互勉励了几句话。当时我们俩都想，也许最多也就是个省一了，不过省一也行啊，给个省一已经知足了，总比那个优秀参赛奖好吧。</p>
<p>可是万万没想到，老师通知下来后，有人通知我们队伍拟报了国一的时候，这个结果真的是“亮瞎了我的双眼”。</p>
<blockquote>
<p>天哪，这是真的吗！</p>
</blockquote>
<p>然后我去找韩老师核实了一下，应该就是国一，因为他当时给我的回复是这样的：</p>
<blockquote>
<p>我：韩老师，省奖名单里没有我们队伍，我们是不是没有奖啊？</p>
<p>韩：你觉得你们怎么样[微笑]?</p>
<p>我：感觉至少应该有个省奖吧，毕竟我们写的还算不差。</p>
<p>韩：那就是国奖了。</p>
<p>我：韩老师我们是国一吗？</p>
<p>韩：[炫酷]。</p>
</blockquote>
<p>其实刚刚提到的<strong>大辽学姐</strong>她们也推了国一，有没有人算一下这个事件发生的概率是多少呢？</p>
<p>一个月后，我和大辽她们队都收到了去西交答辩的通知，答辩通知很突然，晚上10点多通知的，要求次日2点要到。我们简单地做了下PPT，然后理了下头绪，就去参加了答辩。给我们答辩的周义仓教授和韩中庚教授都非常得友好、温柔，平易近人，他们给我们讨论了我们这篇论文很多不足的地方，但并没有任何批评我们的想法，我们也承认了我们的错误，他们也指出了我们这篇论文出彩之处，还询问了我们对数学建模国赛的建议。这次答辩给我们增长了许多经验，刷新了我对数学建模国赛得认识。</p>
<p>图下为周义仓教授和我在陕西师范大学的颁奖典礼的合影。</p>
<p><img src="http://1013rain.me/ZhouandMe.png" alt="ZANDME"></p>
<p>过了大概一周的样子，结果出来了，我们队伍如愿拿到了国一，大辽的队伍拿到了国一以及本科组唯一的MATLAB创新奖<a href="张鹏程，刘辽，陈映宇，获得2015本科组唯一MATLAB创新奖，链接为&lt;http://news.xidian.edu.cn/view.php?id=50960">1</a>（十一的时候都觉得是要拿省奖的节奏了呢-.-）。</p>
<p><img src="http://1013rain.me/Certificate.png" alt="Certificate"></p>
<h2 id="成都观光两日游">成都观光两日游</h2><p>因为2015年电子科技大捧杯，所以颁奖典礼在成都举办，然后我们做着火车去成都，下午到得，住得电子科技大的宾馆（三星级666）。宾馆的条件挺不错的。</p>
<p><img src="http://1013rain.me/hotel.png" alt="Hotel"></p>
<p>当天晚上，韩老师请我们吃了一顿重庆火锅（请不要在意在成都吃重庆火锅），超赞！</p>
<p><img src="http://1013rain.me/huoguo.png" alt="HUOGUO"></p>
<p>次日下午颁奖典礼结束合了个影</p>
<p><img src="http://1013rain.me/ChengduMeeting.png" alt="CHENGDUMEETING"></p>
<p>我和MATLAB工程师卓金武的合影</p>
<p><img src="http://1013rain.me/ZhuoandMe.png" alt="ZhuoandMe"></p>
<p>因为大家过几天要期末考，所以次日晚上就回去了。。。有点可惜吧，我还想去重庆玩会儿再回去呢。</p>
<p>P.S.为啥学校不给报飞机。。飞机好像和卧铺差不了几个钱吧…做卧铺过去再回来真的是想吐了。</p>
<h2 id="END">END</h2>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>去年12月份（2015.12），去成都参加完了数模国赛的颁奖典礼后，我的数模“生涯”终于告了一段落。</p>
<h2 id="<!-more->">]]>
    
    </summary>
    
      <category term="大学生活" scheme="http://1013rain.me/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
      <category term="数模" scheme="http://1013rain.me/tags/%E6%95%B0%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大一一年的学习生活总结]]></title>
    <link href="http://1013rain.me/2015/11/17/my%20first%20year%20in%20XDU/"/>
    <id>http://1013rain.me/2015/11/17/my first year in XDU/</id>
    <published>2015-11-17T06:01:16.000Z</published>
    <updated>2015-11-17T08:03:22.000Z</updated>
    <content type="html"><![CDATA[<p>大二了，本来想开学之初来写一下我的大一，但是一些事情让我拖到了现在。<br>现在，终于有时间这篇文。<br><a id="more"></a></p>
<h2 id="军训">军训</h2><h3 id="教官">教官</h3><p>教官给我的印象是相当不错的。他是国防科技大学的国防生，大四来当我们教官（gap month?)。<br>他管我们管的很松，人也很好，我记得我们九连应该是二团里面训练最轻松的（<code>点个赞！</code>）。<br>由于隔了一年多了然后就记不清多少了= =。。</p>
<h3 id="拉练">拉练</h3><p>说走21.6km的都是混蛋，要是算上从寝室到校门口的距离估计得26.1km，呵呵哒，不过不管是21.6还是26.1我都走完了，走完当天就躺了一下午，第二天就去了病号连(团)。</p>
<h3 id="能记得的趣事">能记得的趣事</h3><p>就记得有几天晚上的时候连里面几个人跑去十连（女生连）去唱(da)歌(shan)，想想还是很有趣的。</p>
<h2 id="军训完刚开学">军训完刚开学</h2><p>开学一天，啥都不懂，第一节课是高数课，因为学长学姐说<code>高数是大学里面最重要的课</code>，然后7:00丧心病狂地到了A311占位，记得当时占的第二排，女生不要打我，那时还不知道前三排是女生坐的（西电习俗）。</p>
<h3 id="开学考试和卓越班面试">开学考试和卓越班面试</h3><p>也许是军训前2个星期每天抽出半个小时看了会数学和英语，还有军训期间抽了点时间听了点听力，考试刚好飘过卓越班的分数线，然后面试水了发暑假装电脑的经历（咳咳，动手能力强？…），然后就进卓越班了XD。<br>感觉卓越班面试挺水的，走个过场吧，面试的时候就一个老(tu)老(lao)师(tou)问我你大学四年打算怎么过，我当时好像回答的是<strong>好好学习，天天向上</strong>。</p>
<h3 id="Others">Others</h3><p>那时候没什么事，就和室友去玩了会视频后期制作；社团试水了下但最后只去了思辨社；学生会去面了电院学生会的技术部，二面杯具了，记得当时那个面试的问题：</p>
<blockquote>
<p>我院有一名视频制作大牛，我们想召他进来干活，但他不想进，如何说服他</p>
</blockquote>
<p>然后一个学长模拟那名大牛，中间的时候，他问我们：</p>
<blockquote>
<p>为什么我一定要去科协，而不是去你们学生会呢？</p>
</blockquote>
<p>无语了，你叫我如何回答，当时就想去科协了。</p>
<hr>
<p>另外，和室友去了钟楼、鼓楼、回民街等等地方玩，感觉还行，但这三个地方感觉并不是必去之地。</p>
<h2 id="学习">学习</h2><p>想想我学习应该还是比较认真的，毕竟大一事少，完成作业还有很多时间做别的事。</p>
<h3 id="学习C语言">学习C语言</h3><p>初接触C语言的时候，看的是谭老的<a href="http://book.douban.com/subject/1047892/" target="_blank" rel="external">《C程序设计》</a>，这本书其实还是不错的，我拿到的教材是第二版，彩印，当时我用他看完了数组以前所有的知识，找了个网站写了点题<a href="codevs.cn/info">wikioi</a>。<br>不久后，了解到ACM/ICPC的存在，这是个很有趣的、但也很痛苦的一个竞赛。<br>因为这个竞赛，我知道了这本书：<a href="http://book.douban.com/subject/25902102/" target="_blank" rel="external">算法竞赛入门经典(第二版)</a>,很喜欢这本书作者的风格。</p>
<h2 id="讲座">讲座</h2><p>有英语口语、C语言、数模讲座，还听了会国创讲座，感觉这些讲座让我了解到了ACM竞赛，数模竞赛然后还有英语口语方面的东西。<br>还是挺有用的。</p>
<hr>
<p>大一下学期，感觉这学期过的很赞，因为对数模竞赛很好奇，就和班上的女神还有原来的室友组了个队打了下数模，记得当时的问题是<code>医院的投入产出效率评价</code>。还记得第三问直接是室友扯完的，佩服佩服啊；女神也很赞，写作棒棒的，而且一教就会，第二问只简单地说了下SPSS怎么用聚类，然后她就用那个软件把聚类做出来了，握手握手，顺便点个赞。另外最后拿了个校一，非常吃惊，后来听老师说是第二问我们用的<strong>Q型系统聚类</strong>刚好是正确的聚类（95%的人都用快速聚类），其他的格式也不错，然后才拿的校一.</p>
<hr>
<p>ACM方面，水了发校赛，网络赛用Ctrl+C，Ctrl+V大法水过去了，最后现场赛的时候4题飘过，二等奖滚粗。之后又水了发省赛，成功参赛奖滚粗23333<br>自己是个ACM蒟蒻的事实估计是改变不了了</p>
<h2 id="大一下最后一个月">大一下最后一个月</h2><p>用一句话来说这个月的内容，那就是刷GPA了，最后好像除了英语马哲都是90多。<br>刷GPA就是不断刷卷子啊刷卷子，枯燥无味，不过最后水了个第一，这个月刷的还是挺值得。</p>
<h2 id="总结">总结</h2><p>感觉大一啥都玩了一遍，练英语，社团，数模，ACM，出去旅游，都体验了一遍，大一完后感觉有了方向（之后有了参加数模国赛还有打算做iOS项目的事情）。<br>再次对自己说一声：加油。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大二了，本来想开学之初来写一下我的大一，但是一些事情让我拖到了现在。<br>现在，终于有时间这篇文。<br>]]>
    
    </summary>
    
      <category term="大学生活" scheme="http://1013rain.me/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[评论者操作系统、浏览器版本显示]]></title>
    <link href="http://1013rain.me/2015/08/16/UAtest/"/>
    <id>http://1013rain.me/2015/08/16/UAtest/</id>
    <published>2015-08-16T10:44:35.000Z</published>
    <updated>2015-08-16T10:59:55.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章是专门用来测试UA(User Agent)的。</p>
<p>关于多说评论UA的显示，具体可以百度，或者私我。</p>
<p>听说凑齐7种操作系统可以召唤神龙<br><a id="more"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章是专门用来测试UA(User Agent)的。</p>
<p>关于多说评论UA的显示，具体可以百度，或者私我。</p>
<p>听说凑齐7种操作系统可以召唤神龙<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[USACO(2.1.1) Castle 解题报告(C++)]]></title>
    <link href="http://1013rain.me/2015/08/15/castle/"/>
    <id>http://1013rain.me/2015/08/15/castle/</id>
    <published>2015-08-15T15:10:49.000Z</published>
    <updated>2015-08-16T11:00:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="题目重述">题目重述</h1><p>大概就是说有一个包含N*M<code>(1&lt;=N,M&lt;=50)</code>房间的城堡，他们可能想通或者不想通，输入<code>N、M</code>和<code>相邻房间是否相通的信息</code>，认为相通的房间总的算一个大房间，求</p>
<ul>
<li>大房间的输目</li>
<li>最大的大房间包含的房间数</li>
<li>仅能打破一堵墙，可以创造出一个新的大房间，输出使得新的大房间最大的<code>被打破墙的位置</code>，这个位置指如果有多个最优解，输出最靠西，然后最靠南的房间的位置。</li>
</ul>
<h1 id="题目分析">题目分析</h1><p>经典种子染色<code>Flood Fill</code>问题，可以使用bfs或者dfs进行染色，相通的房间染成一色，顺便记录相同颜色房间的个数。我使用dfs搜索，具体代码如下<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">52</span>][<span class="number">52</span>],color[<span class="number">52</span>][<span class="number">52</span>],col,row,nowcolor=<span class="number">0</span>,roomsize[<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> xx[<span class="number">4</span>]=&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,yy[<span class="number">4</span>]=&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*g数组存储房间周围的墙的情况、color存房间的染色、roomsize[i]指</span><br><span class="line">  颜色为i的房间的个数，xx、yy是指方向(依次为西、北、东、南）</span><br><span class="line">  深搜所有相通的房间，相通房间染相同的颜色,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check[x][y]) <span class="keyword">return</span>;<span class="comment">/*搜过了，直接return*/</span></span><br><span class="line">    check[x][y]=<span class="literal">true</span>;<span class="comment">/*已经搜到了这个房间*/</span></span><br><span class="line">    color[x][y]=nowcolor;<span class="comment">/*标记房间颜色*/</span></span><br><span class="line">    roomsize[nowcolor]++;<span class="comment">/*统计相同颜色房间对应的个数*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(g[x][y]&amp;(<span class="number">1</span>&lt;&lt;i))) dfs(x+xx[i],y+yy[i]);</span><br><span class="line">        <span class="comment">/*判断i方向是否有墙,i依次为 西、北、东、南，没墙就继续搜*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主函数中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;col,&amp;row);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">        	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">            <span class="keyword">if</span>(!check[i][j])<span class="comment">//如果没搜过这个房间</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowcolor++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...<span class="comment">/*解决下一个问题的代码*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是要找打破墙最优解在哪，根据题目要求，我们需要从房间图的最左下角开搜，优先搜北边的墙，然后再搜东边的墙。不用搜南边和西边的，因为这些墙要么是边界，要么已经被搜过。于是开始暴力搜索</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mwall_x,mwall_y,break_max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> v_wall;</span><br><span class="line"><span class="comment">/* mwall_x,mwall_y 墙对应房间的坐标 break_max新大房间包含房间的最大数目</span><br><span class="line">   v_wall='E',代表该墙在(mwall_x,mwall_y)号房间的东边，'N'则是北边*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_wall</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=col;y++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=row;x&gt;=<span class="number">1</span>;x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[x][y]&amp;<span class="number">2</span> &amp;&amp; color[x][y]!=color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]] &amp;&amp; roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]]]&gt;break_max)</span><br><span class="line">    <span class="comment">/*该房间北边有墙&amp;&amp;墙两边房间的染色不同&amp;&amp;打破后比现在的最优解还好 */</span></span><br><span class="line">    		mwall_x=x,mwall_y=y,break_max=roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]]],v_wall=<span class="string">'N'</span>;</span><br><span class="line">    <span class="comment">/*记录这个最优解*/</span></span><br><span class="line">            <span class="keyword">if</span>(g[x][y]&amp;<span class="number">4</span> &amp;&amp; color[x][y]!=color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]] &amp;&amp; roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]]]&gt;break_max)</span><br><span class="line">                mwall_x=x,mwall_y=y,break_max=roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]]],v_wall=<span class="string">'E'</span>;</span><br><span class="line">        &#125; <span class="comment">/* 先搜这个房间北边的墙，再搜东边的 */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="程序代码">程序代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">ID:1013rai1</span><br><span class="line">PROG:castle</span><br><span class="line">LANG:C++</span><br><span class="line">*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">52</span>][<span class="number">52</span>],color[<span class="number">52</span>][<span class="number">52</span>],col,row,nowcolor=<span class="number">0</span>,roomsize[<span class="number">2505</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> xx[<span class="number">4</span>]=&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,yy[<span class="number">4</span>]=&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mwall_x,mwall_y,break_max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> v_wall;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*深搜所有相通的房间，相通房间染相同的颜色*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check[x][y]) <span class="keyword">return</span>;</span><br><span class="line">    check[x][y]=<span class="literal">true</span>;</span><br><span class="line">    color[x][y]=nowcolor;</span><br><span class="line">    roomsize[nowcolor]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(g[x][y]&amp;(<span class="number">1</span>&lt;&lt;i))) dfs(x+xx[i],y+yy[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_wall</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=col;y++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=row;x&gt;=<span class="number">1</span>;x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[x][y]&amp;<span class="number">2</span> &amp;&amp; color[x][y]!=color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]] &amp;&amp; roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]]]&gt;break_max)</span><br><span class="line">                mwall_x=x,mwall_y=y,break_max=roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">1</span>]][y+yy[<span class="number">1</span>]]],v_wall=<span class="string">'N'</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[x][y]&amp;<span class="number">4</span> &amp;&amp; color[x][y]!=color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]] &amp;&amp; roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]]]&gt;break_max)</span><br><span class="line">                mwall_x=x,mwall_y=y,break_max=roomsize[color[x][y]]+roomsize[color[x+xx[<span class="number">2</span>]][y+yy[<span class="number">2</span>]]],v_wall=<span class="string">'E'</span>;</span><br><span class="line">        &#125; <span class="comment">/* 先搜一个房间北边的墙，最后搜东边 */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"castle.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"castle.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;col,&amp;row);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">            <span class="keyword">if</span>(!check[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                nowcolor++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,nowcolor);</span><br><span class="line">    <span class="keyword">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nowcolor;i++)</span><br><span class="line">        maxsize=max(roomsize[i],maxsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxsize);</span><br><span class="line">    find_wall();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d %d %c\n"</span>,break_max,mwall_x,mwall_y,v_wall);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目重述">题目重述</h1><p>大概就是说有一个包含N*M<code>(1&lt;=N,M&lt;=50)</code>房间的城堡，他们可能想通或者不想通，输入<code>N、M</code>和<code>相邻房间是否相通的信息</code>，认为相通的房间总的算一个大房间，求</p>
<ul>
<li>大房间的输目</li>
<li>最大的大房间包含的房间数</li>
<li>仅能打破一堵墙，可以创造出一个新的大房间，输出使得新的大房间最大的<code>被打破墙的位置</code>，这个位置指如果有多个最优解，输出最靠西，然后最靠南的房间的位置。</li>
</ul>
<h1 id="题目分析">题目分析</h1><p>经典种子染色<code>Flood Fill</code>问题，可以使用bfs或者dfs进行染色，相通的房间染成一色，顺便记录相同颜色房间的个数。我使用dfs搜索，具体代码如下<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://1013rain.me/tags/C/"/>
    
      <category term="USACO" scheme="http://1013rain.me/tags/USACO/"/>
    
      <category term="图论" scheme="http://1013rain.me/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Markdown写文章！]]></title>
    <link href="http://1013rain.me/2015/08/05/startingmarkdown/"/>
    <id>http://1013rain.me/2015/08/05/startingmarkdown/</id>
    <published>2015-08-05T13:43:30.000Z</published>
    <updated>2015-08-16T10:38:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="开始学习Markdown">开始学习Markdown</h1><p>本文的目标主要是为了介绍Mardown的简洁实用和大多数的语法，Markdown现在存在很多的衍生版本，大家可以百度查看。</p>
<h2 id="什么是Markdown">什么是Markdown</h2><p><a href="http://baike.baidu.com/link?url=JvfzthLej3cAtwGlY1jgBJgnnJAkCZZGmGR-PMK5CbOafPLwaX5WQrEdtrRZak4yWkdEJky7H6BehjqAo7bJK_" target="_blank" rel="external">Markdown</a>，它是一种<strong>极其轻量</strong>的<strong>标记</strong>语言，是一种用来书写的语言。它轻量到什么程度呢？下面是我写的Markdown样例代码。<br><a id="more"></a></p>
<pre><code><span class="header"># Hello Markdown!</span>
今天第一次用<span class="strong">**Markdown**</span>写文章，感觉<span class="emphasis">*好轻松啊*</span>~
那Markdown有啥子好处呢？

<span class="bullet">* </span>它语法太简单了。。。
<span class="bullet">* </span><span class="code">`Markdown`</span>不需要排版啊！！
如果想了解更多的话就去看[<span class="link_label">Markdown维基百科</span>](<span class="link_url">https://en.wikipedia.org/wiki/Markdown</span>)
</code></pre><p>我们发现，这段文本和普通文本并没有多少区别，那将它放入Markdown编辑器中会有什么效果呢？请看下面。</p>
<blockquote>
<h1 id="Hello_Markdown!">Hello Markdown!</h1><p>今天第一次用<strong>Markdown</strong>写文章，感觉<em>好轻松啊</em>~<br>那Markdown有啥子好处呢？比如</p>
<ul>
<li>它语法太简单了。。。</li>
<li><code>Markdown</code>不需要排版啊！！</li>
</ul>
<p>如果想了解更多的话就去看<a href="https://en.ikipedia.org/wiki/Markdown" target="_blank" rel="external">Markdown维基百科</a>吧</p>
</blockquote>
<p>看到了吧，Markdown也就这么多语法。总之，Markdown的语法就是由一些<br>符号构成，比如<em>*“</em>“、“`”、“#”，看起来十分得鲜明。</p>
<h2 id="为什么要学习Markdown">为什么要学习Markdown</h2><p>我们平时都为了修改格式而烦恼（尤其是我这种强迫症），现在我们不再需要考虑修改格式了，Markdown控制格式的符号也就几种（就在下面会谈到），相对于Word来说，使用Markdown更方便了，让排版见鬼去吧！</p>
<p>使用Markdown可以显著提高你的码字、写作体验。另外，大多数的Markdown支持输出html文本和pdf文档，而且Markdown编辑器生成的文档还特！别！漂！亮！</p>
<p>另外，Markdown源文本特别易读，很容易修改，不像latex，word。</p>
<p>Markdown的功能还很全，比如可以使用<code>mathjax</code>实现插入数学公式。</p>
<h1 id="让我们开始学习Markdown">让我们开始学习Markdown</h1><h2 id="简要的语法">简要的语法</h2><ul>
<li><p>每一行最开头的<code>#</code>号前缀，作为文章的标题格式，学过html的应该知道，<code>&lt;hx&gt;</code>代表x级标题,markdown也类似，每行开头有几个*就是几级标题。就像这样</p>
<pre><code><span class="preprocessor">##我是一个二级标题    </span>
<span class="preprocessor">###我是一个三级标题</span>
</code></pre></li>
<li><p>特殊的，1级标题和2级标题有一个更随意的用法。</p>
<pre><code><span class="header">我是一个一级标题
=========</span>
<span class="header">我是一个二级标题
-----------</span>
=、-号的数量随便
</code></pre></li>
</ul>
<ul>
<li><p>每一行最开头的<code>&gt;</code>号前缀，用来标记一段文本是引用，而且它还能嵌套。</p>
<pre><code>&gt;我是引用
<span class="prompt">&gt;&gt;</span>这是一个嵌套引用
</code></pre></li>
<li><p>行前用*号加一个空格表示无序列表，用1.表示有序列表，当然我更喜欢那个前者生成的小点，好看啊：</p>
<pre><code>* 数学建模竞赛
* 程序设计竞赛

<span class="number">1.</span>培养团队合作水平
<span class="number">2.</span>培养自身能力
<span class="number">3.</span>提高查找资料的能力
</code></pre></li>
</ul>
<ul>
<li><p>我们用回车产生空行，来分隔段落（很好理解吧，每个段落都空几行以区分开来~）</p>
</li>
<li><p>段落中使用<code>*</code>或<code>**</code>来标记强调（斜体）或粗体。</p>
<pre><code><span class="keyword">*</span>我要被强调<span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span>我要被画粗<span class="keyword">*</span><span class="keyword">*</span>
</code></pre></li>
<li><p>使用表格，表格可能比较麻烦，因为它需要这样：</p>
</li>
</ul>
<pre><code>|<span class="string"> Tables        </span>|<span class="string"> Are           </span>|<span class="string"> Cool  </span>|
|<span class="string"> ------------- </span>|<span class="string">:-------------:</span>|<span class="string"> -----:</span>|
|<span class="string"> col 3 is      </span>|<span class="string"> right-aligned </span>|<span class="string"> $1600 </span>|
|<span class="string"> col 2 is      </span>|<span class="string"> centered      </span>|<span class="string">   $12 </span>|
|<span class="string"> zebra stripes </span>|<span class="string"> are neat      </span>|<span class="string">    $1 </span>|
</code></pre><ul>
<li><p>使用超链接，如果要创建一个名字为“百度”，地址为www.baidu.com的超链接，可以这样：</p>
<pre><code>[<span class="link_label">百度</span>](<span class="link_url">www.baidu.com</span>)
还可以直接用显示连接：(www.baidu.com)
</code></pre></li>
<li><p>使用图片，如果加载一个图片，和上者类似,只要再加：</p>
<pre><code>![<span class="link_label">图片的名称</span>](<span class="link_url">www.example.com/example.jpg</span>)
</code></pre></li>
<li><p>使用行内代码，只要对代码``圈住就行了，比如：</p>
<pre><code>对于fibonacci数列的第<span class="keyword">n</span>+1项来说，有状态转移方程`dp[<span class="keyword">n</span>+1]=dp[<span class="keyword">n</span>]+dp[<span class="keyword">n</span>-1]`。
</code></pre></li>
<li><p>要对一段画删除线，只要在这个文本前后加上<code>~~</code>:</p>
<pre><code>~~被划了一道~~
</code></pre></li>
<li><p>我们在每一行最前面加上4个空格或一个以上的tab制表符来表示这个一个code block。</p>
</li>
<li><p>如果要输出”*“这类表示本来在Markdown中表示格式的字符怎么办？与C语言类似地，使用转义字符\来解决问题，想输出*号，你需要在它前面加上反斜杠。</p>
<pre><code>就像这样：<span class="command">\*</span>、<span class="command">\`</span>、<span class="command">\_</span>
</code></pre></li>
</ul>
<h2 id="Markdown支持html标签">Markdown支持html标签</h2><p>Markdown其实就是html的子语言，所以它也支持html标签。比如下标<code>&lt;sub&gt;2&lt;/sub&gt;</code>。你如果需要使用html标签直接把它加进去就行了。</p>
<h2 id="马上在各大平台上尝试Markdown！">马上在各大平台上尝试Markdown！</h2><ul>
<li>Mac</li>
</ul>
<p><code>Mou</code>、<code>Macdown</code>、<code>Markdown plus</code></p>
<ul>
<li>Linux</li>
</ul>
<p><code>ReText</code></p>
<ul>
<li>Windows</li>
</ul>
<p><code>Markdown pad2</code></p>
<ul>
<li><p>网页<br><a href="http://mahua.jser.me" target="_blank" rel="external">mahua</a>、<a href="https://stackedit.io" target="_blank" rel="external">StackEdit</a></p>
</li>
<li><p>sublime text也可以作为Markdown的编辑器，不过不支持实时转化，需要有插件的支持才能实时转化，具体请看<a href="http://www.jianshu.com/p/378338f10263" target="_blank" rel="external">简书，sublime text2下的markdown写作</a></p>
</li>
</ul>
<h2 id="更详细的Markdown教程">更详细的Markdown教程</h2><ul>
<li><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明，简体中文版</a></li>
<li><a href="http://www.markdown.cn" target="_blank" rel="external">Markdown教程</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="开始学习Markdown">开始学习Markdown</h1><p>本文的目标主要是为了介绍Mardown的简洁实用和大多数的语法，Markdown现在存在很多的衍生版本，大家可以百度查看。</p>
<h2 id="什么是Markdown">什么是Markdown</h2><p><a href="http://baike.baidu.com/link?url=JvfzthLej3cAtwGlY1jgBJgnnJAkCZZGmGR-PMK5CbOafPLwaX5WQrEdtrRZak4yWkdEJky7H6BehjqAo7bJK_">Markdown</a>，它是一种<strong>极其轻量</strong>的<strong>标记</strong>语言，是一种用来书写的语言。它轻量到什么程度呢？下面是我写的Markdown样例代码。<br>]]>
    
    </summary>
    
      <category term="技术" scheme="http://1013rain.me/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构重点]]></title>
    <link href="http://1013rain.me/2015/08/04/learn%20Data%20Structure/"/>
    <id>http://1013rain.me/2015/08/04/learn Data Structure/</id>
    <published>2015-08-04T15:40:48.000Z</published>
    <updated>2015-08-04T16:38:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第零章_绪论">第零章 绪论</h2><p>什么是计算机算法？算法的<strong>五大特征</strong>？算法设计的要求？</p>
<ul>
<li><p>计算机算法指<code>解决问题的步骤序列</code>。</p>
</li>
<li><p>算法的五大特征分别为</p>
<pre><code>可行性、有穷性、确定性、输入、输出
</code></pre></li>
<li><p>算法设计要求</p>
<pre><code>正确性、可读性、健壮性、效率与低存储量需求
</code></pre><a id="more"></a>
<p>你得学会分析一个算法的时间复杂度，至于空间复杂度，后者好分析，你只要保证你会前者就行了。</p>
</li>
</ul>
<p>如何分析一个算法的时间复杂度？</p>
<p>从我们现在接触的算法来看，<em>log N</em>的产生是因为<strong>二分</strong>，N的产生是因为for/while循环，大概地，一层循环乘一个N，二分的循环乘 <em>log N</em>。（但这只是一种<code>感觉</code>，请不要当真，因为KMP算法中<code>匹配函数</code>的时间复杂度是O(N)<a href="《算法导论》">^3</a>，虽然有2层循环…）</p>
<p>比如快速排序，就有二分的思想，又循环一次，你懂的， <strong>O(NlogN)</strong>，冒泡，选择排序，插入排序，二次循环，<strong>O(N<sup>2</sup>)</strong>。</p>
<p>如果一个算法要算3*n^2+n+1次，它时间复杂度并非O(3*n^2+n+1),而是O(n^2)，时间复杂度只取决于指数最高的那一项，且忽略常数项。<br>然后有一些<strong>概念你要知道</strong>,在<strong>书1.2节</strong>。</p>
<ul>
<li>从逻辑上把数据结构分成<strong><em>线性结构和非线性结构</em></strong></li>
<li>物理结构是<strong>数据结构在计算机中的表示</strong></li>
<li><strong>数据</strong>是对客观事物的符号表示。</li>
<li><strong>数据元素</strong>是数据的基本单位。</li>
<li><strong>数据对象</strong>是性质相同的数据元素。</li>
<li><strong>数据结构</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</li>
<li>数据元素之间的关系在计算机中的<strong>两种不同的表示方法</strong>：<strong>顺序映像</strong>和<strong>非顺序映像</strong>。</li>
<li>两种不同的存储结构：顺序存储结构和链式存储结构。</li>
<li>数据的逻辑结构指<strong><em>数据元素之间的逻辑关系</em></strong></li>
<li><strong>抽象数据类型</strong>是指一个数学模型以及定义在该模型上的一组操作。</li>
<li>以上概念考<strong><em>填空题</em></strong>的概率较大。</li>
</ul>
<h2 id="第一章_线性表">第一章 线性表</h2><p>必考：该章没什么好说的，简单，但有可能写代码，请注意要会所有<strong>概念，也就是原理</strong>。<br>还有<strong>线性表（顺序存储结构）和链表（链式存储结构）的优劣性，比如链表插入时间复杂度是O(1)，而线性表是O(N)；线性表有存储上限，但链表没有</strong>。刚刚说的优劣性，是可以拿性命担保必考的。</p>
<p>代码的话，很可能是写往线性表（或链表）插入一个元素之类的，只求过的话代码你就可以不用会写了。</p>
<p>线性表插入一个元素的e.g:</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>{
    <span class="keyword">int</span> a[MAXLEN];<span class="comment">//数组实现</span>
    <span class="keyword">int</span> end;
}<span class="built_in">list</span>; <span class="comment">// typedef一个list类型</span>

<span class="function"><span class="keyword">void</span> <span class="title">MoveTheElemsToright</span><span class="params">(<span class="built_in">list</span> *l,<span class="keyword">int</span> n)</span></span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = l-&gt;end; i&gt;=n; i--)
        l-&gt;a[i+<span class="number">1</span>]=l-&gt;a[i];
}<span class="comment">//腾出第n+1个空间（将第n+1数开始往右移一格）</span>

<span class="function"><span class="keyword">bool</span> <span class="title">InstertAnElemNormal</span><span class="params">(<span class="built_in">list</span> *l,<span class="keyword">int</span> n,<span class="keyword">int</span> number)</span></span>{
    <span class="keyword">if</span>(n&gt;l-&gt;end+<span class="number">1</span>||n&lt;<span class="number">0</span>||l-&gt;end==MAXLEN-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//加强鲁棒性，然而并没有什么软用！</span>
    <span class="keyword">else</span> MoveTheElemsToright(l,n);
    l-&gt;a[n] = number;
    l-&gt;end++;
    <span class="keyword">return</span> <span class="literal">true</span>;
}<span class="comment">// insert an elem at the (n+1)th place</span>
</code></pre><h2 id="第二章_栈和队列">第二章 栈和队列</h2><p>这都是基础的数据结构，同样有可能写(伪)代码实现，同样要会所有<strong>概念</strong>。</p>
<p>连概念都不懂的可以去看 </p>
<ul>
<li>严奶奶的书</li>
<li><a href="http://blueve.me/archives/417" target="_blank" rel="external">我叫<strong>队列还有bfs(他们是分开的所以你可以不看后者23333)</strong>概念的传送门</a></li>
<li><a href="http://www.baidu.com" target="_blank" rel="external">我真找不到谁的博客详细写了栈的概念，栈原理不懂的话，这个是百度的传送门</a></li>
</ul>
<p>堆栈实际上就是 <strong>先入后出</strong>(first in last out),队列是<strong>先入先出</strong>(first in first out)。</p>
<p>这章考代码的概率应远小于 <strong>某表</strong>。</p>
<h3 id="插播一条概念">插播一条概念</h3><ul>
<li>前驱和后继</li>
</ul>
<p><strong>一个元素的前驱或后继实质上</strong>指这个它的<strong>前一个元素</strong>和<strong>后一个元素</strong>。二叉排序树中要找一个元素的中序遍历前驱，就是要在小于它的元素中找最大的（就是找小于它的且<strong>最靠近它的元素</strong>）。中序遍历后继类似，不说了（关键字：大于，最靠近）。</p>
<h2 id="第三章_串">第三章 串</h2><p>只有一条好消息，<strong>KMP算法</strong>不考哦～，但防止万一，请记下它的算法<strong>时间复杂度 O(M+N)</strong>。</p>
<h2 id="第四章_数组和广义表">第四章 数组和广义表</h2><p>广义表如果考的话应该也就考 <strong>一个广义表的(深)度</strong>了。数括号就行了。还可能</p>
<p>e.g.</p>
<ul>
<li><code>(a,(a))</code> 深度是 <strong>2</strong></li>
<li><code>(a,b,(a,(b,c)))</code> 是 <strong>3</strong></li>
<li><p><code>(a,b,(a,(a,c,(d,e))),(x))</code> 是 <strong>4</strong></p>
</li>
<li><p><a href="http://zuoye
.baidu.com/question/138683737c1d72161a5d0cda8a916904.html" target="_blank" rel="external">这是关于广义表如何算长度和深度的传送门</a></p>
</li>
<li><p><a href="http://zuoye.baidu.com/question/07abdcc3913d3a44e82b57db82fb1da8.html" target="_blank" rel="external">这是关于head和tail的传送门(做试卷的应该都看过这俩名词)</a></p>
</li>
</ul>
<p>另外关于8号楼下数据结构期末题第一套的<code>数组题</code></p>
<pre><code>将一个A[<span class="link_label">100</span>][<span class="link_reference">100</span>]的三对角矩阵，按行优先存入一维数组B[<span class="link_label">298</span>]中，数组下标从0开始编号，A中的元素A[<span class="link_label">65</span>][<span class="link_reference">64</span>]再B中的位置K为<span class="strong">_____</span>。
应填194，a[<span class="link_label">65</span>][<span class="link_reference">64</span>]上面有64*3+2=194个元素。a[<span class="link_label">65</span>][<span class="link_reference">64</span>]是第195个，而数组从0开始编号，所有B[<span class="link_label">194</span>]存储了A[<span class="link_label">65</span>][<span class="link_reference">64</span>]。
</code></pre><p>这里普及一下<code>三对角矩阵</code>，这就是三对角矩阵（4*4的）<br><img src="https://upload.wikimedia.org/math/e/b/c/ebc3ab5369e2fc1a1d2bb0dd68396027.png" alt="三对角矩阵"></p>
<p>最左边的矩阵就是三对角矩阵<br><img src="https://upload.wikimedia.org/math/f/a/8/fa8a518330d0e8da1a0890bb2e587043.png" alt="big"></p>
<h2 id="第五章_树">第五章 树</h2><p>树就考很多了，树的<strong>前中后序遍历</strong>你要是还不懂概念就快看书吧！！！！！~~这个遍历至少考5分以上。<br>~~哈夫曼树估计也是要考的，大概是<strong>给定一个序列，然后构建一个哈夫曼树</strong>。</p>
<p>树的遍历备考知识（说起来可能比较多，看不懂的去百度）</p>
<pre><code>给出先序遍历和后序遍历。输出这棵二叉树。
<span class="number">1</span>.先序的第一个是根<span class="literal">a</span>。
<span class="number">2</span>.先序序列 根的后一个节点b只可能是根的左右节点之一。
<span class="number">3</span>.如果中序中b出现在<span class="literal">a</span>之前，b是<span class="literal">a</span>的左儿子，反之是儿子。
<span class="number">4</span>.中序中<span class="literal">a</span> 左边的是<span class="literal">a</span>左子树的中序遍历，右边则是<span class="literal">a</span>右子树的中序遍历。
<span class="number">5</span>.第四点对所有假定的根都成立，递归得出这棵二叉树。
</code></pre><p>树、森林和二叉树的转换<br><a href="http://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html" target="_blank" rel="external">link(来源于cnblog)</a></p>
<p>怎么构建<code>哈夫曼树</code>？</p>
<pre><code>哈夫曼树的构造算法

假设有n个权值，则构造出得哈夫曼树有n个叶子结点。n个权值分别设为w1,w2,...,wn,则哈夫曼树的构造规则为:

<span class="params">(<span class="number">1</span>)</span>将w1,w2,...,wn看成是有n棵树的森林<span class="params">(每棵树仅有一个结点)</span>;
<span class="params">(<span class="number">2</span>)</span>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
<span class="params">(<span class="number">3</span>)</span>从森林中删除选取的两棵树，并将新树加入森林;
<span class="params">(<span class="number">4</span>)</span>重复<span class="params">(<span class="number">2</span>)</span>、<span class="params">(<span class="number">3</span>)</span>步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。
</code></pre><p>结合上面的可以再看看下面的图解</p>
<ul>
<li><a href="http://www.th7.cn/Program/c/201410/304813.shtml" target="_blank" rel="external">又见哈夫曼树图解传送门，可是该门广告多</a></li>
<li>听说<code>可以停用**Javascript**屏蔽广告，懂了人以后都看不到广告了哈哈哈哈</code></li>
</ul>
<h2 id="第六章_哈希表">第六章 哈希表</h2><p>这章必考，大概就是类似ppt那样的考法<br>不会的去看书<br> <a href="http://down5.cr173.com/soft1/shujujiegou.rar" target="_blank" rel="external">我叫严蔚敏的数据结构pdf下载传送门</a></p>
<p>处理冲突的方法百度有介绍<br><a href="http://baike.baidu.com/link?url=Jz0q6Ewkh4qUNI6yBiQpuIbUCU5Rfllul1cxi0-26jil8BN_wUq-gERwI2-n48mPyxM6T46DKXy8uaMDV2MgnK" target="_blank" rel="external">百度百科：哈希表</a>，直接翻到处理<code>冲突</code>的那一块看就好了，当然<code>构造</code>方法也得看看。</p>
<p>另外还有<a href="http://blog.csdn.net/wangran51/article/details/8826633" target="_blank" rel="external">平均查找长度的计算</a>，也是可能考的。</p>
<p>(友情提示：用CMCC-EDU的同学很可能打不开该链接，因为移动好像<code>墙</code>了csdn.net，据说github都被墙了)</p>
<h2 id="第七章_图论">第七章 图论</h2><p>这章你需要会<strong>图的遍历</strong>。还有一些基本概念比如说<code>结点的度</code>。</p>
<ul>
<li><a href="http://blueve.me/archives/417" target="_blank" rel="external"><strong>队列实现bfs</strong></a></li>
<li><a href="http://jingyan.baidu.com/article/00a07f38babf4182d028dca2.html" target="_blank" rel="external"><strong>dfs</strong></a></li>
<li>实际上树也是一个图，树的先序中序后序遍历都是<strong>深度优先遍历</strong></li>
<li>一般来说是用栈或者<code>队列</code>实现bfs,用<code>函数递归</code>实现dfs（<strong>回溯法</strong>的基本做法）。</li>
</ul>
<p>###生成树</p>
<pre><code>　如果连通图<span class="keyword">G</span>的一个子图是一棵包含<span class="keyword">G</span>的所有顶点的树，则该子图称为<span class="keyword">G</span>的生成树(SpanningTree)。
　生成树是连通图的包含图中的所有顶点的极小连通子图。
　图的生成树不惟一。从不同的顶点出发进行遍历，可以得到不同的生成树。
</code></pre><h3 id="最小生成树">最小生成树</h3><p>如何画最小生成树？</p>
<p>摘自 <code>百度知道</code>（原来百度知道里也是有有用的答案的Orz）</p>
<pre><code><span class="number">1</span>） 树是无回路的连通图。
<span class="number">2</span>）对于某个图，求它的最小生成树，比较简单的方法，先画出图中所有节点，从权值最小的边开始依次连接顶点，注意不要    形成回路，最后得到的图就是最小生成树。
</code></pre><h2 id="第八章_二分查找">第八章 二分查找</h2><ul>
<li><code>谨记</code>二分查找的数据结构必须是<code>有序</code>的</li>
<li>假如是用<code>链式存储</code>数据，即使元素有序，我看你怎么<code>二分</code>（期末题第一套12.梗）</li>
</ul>
<h3 id="二叉排序树">二叉排序树</h3><ul>
<li>中序遍历二叉排序树的结果必然是一个有序的序列（比如从小到大）</li>
</ul>
<h4 id="如何构建二叉排序树？">如何构建二叉排序树？</h4><p>百度百科是这么规定二叉排序树的</p>
<pre><code>    二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
（<span class="number">1</span>）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
（<span class="number">2</span>）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
（<span class="number">3</span>）左、右子树也分别为二叉排序树；
（<span class="number">4</span>）没有键值相等的节点。
</code></pre><p>再给你看个二叉排序树的图<br>这是对序列<code>(8,3,10,1,6,4,14,7,13)</code> 建立二叉排序树的结果<br><img src="http://pic002.cnblogs.com/images/2012/457289/2012110918051618.jpg" alt="img"></p>
<p>先把8作为根，然后3比8小，成为8的左儿子。10比8大，作为8的右儿子。1比8小，再比3小，作为3的左儿子….</p>
<p>如果还不懂就去看<code>严奶奶的书(diyu)</code>吧 23333333</p>
<h2 id="第九章_排序">第九章 排序</h2><p>O(n^2)的排序就不说了，直接说O(n<sup>1.5</sup>)和O(nlogn)的</p>
<p><code>希尔排序</code>O(n<sup>1.5</sup>)</p>
<ul>
<li><p>希尔排序有一个关键的概念叫“步长”(gap)</p>
</li>
<li><p>建议到这里看<a href="http://blog.csdn.net/morewindows/article/details/6668714" target="_blank" rel="external">希尔排序</a></p>
</li>
</ul>
<p>迷之希尔排序只有4行代码</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>{
    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)
        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++)
            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; a[j + gap]; j -= gap)
                swap(a[j], a[j + gap]);<span class="comment">//swap是交换的意思</span>
}
</code></pre><p>后面都是O(nlogn)的</p>
<p><code>快速排序</code> </p>
<p>快速排序简单吧，直接看老严的书你也能懂，不过代码优点难写，可是<code>老师肯定不考代码的啦</code>。</p>
<p>不过还是给的我自己写的？</p>
<pre><code>void quicksort(int <span class="literal">a</span>[],int l,int r){
    <span class="keyword">if</span>(l&lt;r){
    int ll = l , rr = r , cmp = <span class="literal">a</span>[l]<span class="comment">;</span>
    <span class="keyword">while</span>(ll&lt;rr){
        <span class="keyword">while</span>(ll&lt;rr&amp;&amp;<span class="literal">a</span>[rr]&gt;cmp)
            rr--<span class="comment">;</span>
        <span class="literal">a</span>[ll]=<span class="literal">a</span>[rr]<span class="comment">;</span>
        <span class="keyword">while</span> (ll&lt;rr&amp;&amp;<span class="literal">a</span>[ll]&lt;=cmp) {
            ll++<span class="comment">;</span>
        }
        <span class="literal">a</span>[rr]=<span class="literal">a</span>[ll]<span class="comment">;</span>
    }
    <span class="literal">a</span>[ll]=cmp<span class="comment">;</span>
    quicksort(<span class="literal">a</span>,l, ll-<span class="number">1</span>)<span class="comment">;</span>
    quicksort(<span class="literal">a</span>,ll+<span class="number">1</span>, r)<span class="comment">;</span>
}//咋一看连swap都没有，肯定有问题？不，你仔细看看这个代码，没有问题。
</code></pre><p><code>归并排序</code></p>
<p>归并排序是一种体现<code>分治思想</code>的排序算法，它是我们现在所学到的O(nlogn)算法里唯一一个排序<code>稳定</code>的算法。</p>
<ul>
<li>这个我建议数据结构较好的去看<code>算法--C语言实现（第1～4部分）</code>这本书，当然你想挑战<code>老严的diyu</code>我也是十分<code>赞(fan)成(dui)</code>的，其他的可以去看，《大话数据结构》，当然你想挑战<code>老严的diyu</code>我就………………</li>
<li>还建议看<a href="https://zh.wikipedia.org/zh-hk/归并排序" target="_blank" rel="external">维基百科 归并排序</a></li>
</ul>
<p>顺便贴代码</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r,<span class="keyword">int</span> aux[])</span></span>{
    <span class="keyword">int</span> cnt;<span class="comment">//index      e.g. aux[cnt]</span>
    <span class="keyword">int</span> l1 = l,r1 =mid,l2 = mid + <span class="number">1</span>,r2 = r;
    <span class="keyword">for</span> (cnt = l; cnt &lt;=r; cnt++) {
        <span class="keyword">if</span>(l1==r1+<span class="number">1</span>) {aux[cnt]=a[l2++];<span class="keyword">continue</span>;}
    <span class="keyword">if</span>(l2==r2+<span class="number">1</span>) {aux[cnt]=a[l1++];<span class="keyword">continue</span>;}
    aux[cnt] = (a[l2] &lt; a[l1]) ? a[l2++] : a[l1++] ;
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i&lt;=r ;i++)
        a[i] = aux[i];
}<span class="comment">//归并两个给定数组 思想来自于《算法－－C语言》的"合并两个数组"</span>

<span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> aux[])</span></span>{
<span class="keyword">if</span> (l&lt;r){
    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;
    mergesort(a,l,mid,aux);
    mergesort(a,mid+<span class="number">1</span>,r,aux);<span class="comment">//递归分割</span>
    mergeArray(a,l,mid,r,aux);<span class="comment">//将有序数组归并</span>
}
}

<span class="function"><span class="keyword">bool</span> <span class="title">Mergesort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>{
    <span class="keyword">int</span> *aux = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);<span class="comment">//aux意思是辅助数组</span>
    <span class="keyword">if</span>(aux==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"error!"</span>&lt;&lt;endl,<span class="literal">false</span>;
    mergesort(a,<span class="number">0</span>,n-<span class="number">1</span>,aux);
    <span class="built_in">free</span>(aux);
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h2 id="堆排序">堆排序</h2><h4 id="学渣止步…这个排序可能有点难。">学渣止步…这个排序可能有点难。</h4><p>说到堆排序，首先要介绍一下<code>堆</code>的概念。</p>
<h3 id="堆">堆</h3><p>定义一（堆有序的定义）:如果一棵树中每个节点的关键字都不小于所有子节点的<code>值，或者说是关键字</code>(如果子节点存在的话)，那么久称这棵树是<code>堆有序</code>的。同样的，一棵<code>堆有序</code>中节点的关键字小于等于那个父节点的关键字（如果父节点存在）。[^1]</p>
<p>定义二：<strong><code>堆</code></strong>是一个节点的集合，表示为<code>数组</code>，其中<em>关键字按照<strong>堆有序</strong>的<strong>完全二叉树</strong>的形式排列</em>。</p>
<p>性质一：若a是一个<code>小顶堆</code>，那么a[0]是堆中最小的元素。</p>
<p>定义一中的堆实际上是<code>小顶堆</code>，还有一个概念是<code>大顶堆</code>，这个在后面会有提到。</p>
<p>如何利用堆将一个数组从大到小排序呢？</p>
<h4 id="堆排序-1">堆排序</h4><ul>
<li>堆排序的思想类似于选择排序，也是每次找到一个最大(小)的数，然后在其余的数里找到最大(小)的，只不过每次只需要log(n)次计算，而不是n。</li>
<li>大概就是先让其符合<code>小顶堆</code>的性质，也就是<code>堆化</code>，然后再fixdown n-1次,伪代码是这样的</li>
<li>fixdown的意思是<code>自顶向下堆化</code>，MinFixdown(a,0,i)中，i是堆元素的数量，0表示从a[0]开始堆化，就是<code>堆化以i为结尾的a数组</code>！</li>
<li><p>下面给出<code>从大到小排序</code>的堆排 <code>算法</code></p>
<pre><code>algorithm heapsort(a[],n)<span class="comment">{
    MakeMinHeap(a) % 堆化数组a a变为最小堆
    for i n-1-&gt;1  % swap后 a[0]~a[i]就不一定还是堆了！需要继续fixdown
        MinFixdown (a,0,i) % a[0]~a[i]视为一个(子)堆，fixdown这个(子)堆
        swap(a[0],a[i]) % fix后由堆的性质一可知a[0]是a[0]~a[i]里最小的，把找到的最小的，也就是a[0],放到最后面
    end 
}</span> %堆排序完成，排完序后 小顶堆被完全破坏 ，堆中
</code></pre></li>
<li><p>你们加油 <a href="https://zh.wikipedia.org/zh-hk/堆排序" target="_blank" rel="external">維基百科 堆排序</a></p>
</li>
<li><p>csdn博客里有一个白话算法系列，那里写的这个<code>堆排序</code>算法可以去看看，。</p>
</li>
<li><p>下方有个堆排动态图<a href="维基百科－－堆排序（繁体）">^2</a></p>
</li>
</ul>
<p>下方是我整理的从大到小堆排的代码，代码出自上面那个blog。<br>首先是fixdown函数，从元素a[i]开始，n为数组上界</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">MinHeapFixDown</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span>{
    <span class="keyword">int</span> j, temp;
    temp = a[i];
    j = <span class="number">2</span> * i + <span class="number">1</span>;
    <span class="keyword">while</span> (j &lt; n)
    {
        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; a[j + <span class="number">1</span>] &lt; a[j])
            j++;
        <span class="keyword">if</span> (a[j] &gt;= temp)
            <span class="keyword">break</span>;
        a[i] = a[j];
        i = j;
        j = <span class="number">2</span> * i + <span class="number">1</span>;
    }
    a[i] = temp;
}
</code></pre><p>构建小顶堆</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">MakeMinHeap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>{<span class="comment">//自顶向下地构建小顶堆</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)
        MinHeapFixDown(a, i, n);
}
</code></pre><p>堆排序</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>{
    MakeMinHeap(a,n);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--){
        MinHeapFixDown(a, <span class="number">0</span>, i);
        swap(a[i], a[<span class="number">0</span>]);
        }
}
</code></pre><p>swap函数</p>
<pre><code><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>{<span class="comment">//&amp;是C++的特性，&amp;是引用的意思，&amp;类似于指针，但是作用比指针弱，该函数引用了a变量，这个函数里改变a变量是真的会改变传入的a的值的。（也就是a在函数里是是参）inline是内联函数的关键词，不用管它，只是为了加快速度</span>
    <span class="keyword">int</span> t=a;
    a = b;
    b = t;
}
</code></pre><p><code>关于这些排序的比较</code></p>
<ul>
<li><p>(数据结构期末题第一套10.)一个序列，如果要找出最大的x个元素，则采用<strong>__</strong>。</p>
<p>  应该是<code>堆排序</code>。具体看《算法－－C语言实现》<strong>P241图9-10及其下方的注解</strong>。<br>  也可以看这个动态图<br>  <img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt="img"></p>
<pre><code>这个图也可以帮你理解堆排序的原理。
</code></pre></li>
<li><p>(数据结构期末题第一套15.) </p>
<p>  <code>堆排序</code>，快排递归调用O(logn)的空间，归并固定O(n),堆排O(1)。堆排空间性能最好。</p>
</li>
<li><p>(数据结构期末题第一套9.) </p>
<p>  其实冒泡最省时间，因为冒泡在这个情况下是<strong><em>O(n)</em></strong>，而平均最快的快排却是<strong><em>O(n<sup>2</sup>)</em></strong></p>
</li>
</ul>
<ul>
<li>快排平均最快，归并其次，堆排是O(nlogn)里最慢的</li>
</ul>
<p>[^1]:《算法－－C语言实现》第1～4部分 9.2节</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第零章_绪论">第零章 绪论</h2><p>什么是计算机算法？算法的<strong>五大特征</strong>？算法设计的要求？</p>
<ul>
<li><p>计算机算法指<code>解决问题的步骤序列</code>。</p>
</li>
<li><p>算法的五大特征分别为</p>
<pre><code>可行性、有穷性、确定性、输入、输出
</code></pre></li>
<li><p>算法设计要求</p>
<pre><code>正确性、可读性、健壮性、效率与低存储量需求
</code></pre>]]>
    
    </summary>
    
      <category term="大学课程" scheme="http://1013rain.me/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的第一篇文章]]></title>
    <link href="http://1013rain.me/2015/08/04/helloworld/"/>
    <id>http://1013rain.me/2015/08/04/helloworld/</id>
    <published>2015-08-04T15:40:48.000Z</published>
    <updated>2015-08-06T16:14:19.000Z</updated>
    <content type="html"><![CDATA[<p>hi，现在我终于创建了一个blog，这个blog将被用于记录我的生活、C/C++学习记录还有可恶的数模＝ ＝<br>暂时就是这样了～～～～<br><a id="more"></a><br>由于还是刚刚创建，我需要逐步添加一些功能，这需要一些时间，在这期间，这个blog可能会不太完善，我会加把劲努力的！</p>
<p>一起分享学习经验吧～</p>
<p>吴宇寰</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>hi，现在我终于创建了一个blog，这个blog将被用于记录我的生活、C/C++学习记录还有可恶的数模＝ ＝<br>暂时就是这样了～～～～<br>]]>
    
    </summary>
    
  </entry>
  
</feed>